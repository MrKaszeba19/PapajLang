procedure read_sourcefile(filename : String; var env : PSEnvironment; var db : PSCommandDB);
var
  fun, S : String;
  fp     : Text;
begin
  fun := '';
  assignfile(fp, filename);
  reset(fp);
  while not eof(fp) do
  begin
    readln(fp, S);
    if (S <> '') then S := trim(S);
    fun := fun + #10 + S;
  end;
  closefile(fp);
  //pocz := parseScoped(fun, pocz, sets, vardb);
  env.executePSCode(fun);
end;

// COMMANDS' EXECUTION

function lib_ultravanilla(i : String; var env : PSEnvironment; var db : PSCommandDB) : Boolean;
var
	Found          : Boolean;
	x, y, z, a     : Extended;
	Size           : Longint;
	index          : Longint;
	IntEax         : LongInt;
	StrEbx         : String;
	StrEcx         : String;
	EntEax, EntEbx : Entity;
	ExtEax         : Extended;
    LogEax         : Boolean;
	HelpETable     : array of Entity;
begin
	Found := true;
	case i of
        '^' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            //if (y = ftrunc(y)) then begin
            if (isInteger(y)) then begin
            	z := pow(x,y);
            end else begin
                z := pow2(x,y);
            end;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'pow' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (isInteger(y)) then begin
            	z := pow(x,y);
            end else begin
            	z := pow2(x,y);
            end;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'log' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := ln(x)/ln(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'exp' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := exp(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'ln' : begin
          	if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := ln(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'root' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := root(x,y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        


        // constants
        'NULL' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNull());
        end;
        '[]' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNewArray(env.Stack, env.Settings, 0));
        end;
        'INF' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(Infinity));
        end;
        '+INF' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(Infinity));
        end;
        '-INF' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(-Infinity));
        end;
        '+Inf' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(Infinity));
        end;
        '-Inf' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(-Infinity));
        end;
        'NaN' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(NaN));
        end;

        // unary
		'trunc' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := ftrunc(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'frac' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(ffrac(z)));
        end;
		'sqrt' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := sqrt(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;

        // String operations
        
        'call' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;  
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            env.doFunction(trunc(EntEax.Num));
        end;
        'callIf' : begin
            if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, TBOO, i)) then Exit; 
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TFUN) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;  
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TBOO, i)) then Exit;  
                if stack_pop(env.Stack[env.Settings.StackPointer]).Num = 0 then 
                    env.doFunction(trunc(EntEax.Num));
            end else begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TBOO, i)) then Exit;  
                if stack_pop(env.Stack[env.Settings.StackPointer]).Num = 0 then 
                begin
                    if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;  
                    EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                    env.doFunction(trunc(EntEax.Num));
                end else begin
                    if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;  
                    //StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                end;
            end;
        end;   
        'callUnless' : begin
            if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, TBOO, i)) then Exit; 
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TFUN) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;  
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TBOO, i)) then Exit;  
                if stack_pop(env.Stack[env.Settings.StackPointer]).Num <> 0 then 
                    env.doFunction(trunc(EntEax.Num));
            end else begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TBOO, i)) then Exit;  
                if stack_pop(env.Stack[env.Settings.StackPointer]).Num <> 0 then 
                begin
                    if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;  
                    EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                    env.doFunction(trunc(EntEax.Num));
                end else begin
                    if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;  
                    //StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                end;
            end;
        end;   
        'callTimes' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;  
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            for IntEax := 1 to trunc(y) do
                env.doFunction(trunc(EntEax.Num));
            //
        end; 
        'callWhile' : begin
            if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, TEXP, i)) then Exit; 
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TFUN) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;  
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;  
                EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                //doWhileOld(StrEbx, EntEax.Str, env.Stack, env.Settings, env.Variables);
                env.doWhile(db, trunc(EntEbx.Num), trunc(EntEax.Num));
            end else begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;  
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TEXP, i)) then Exit;  
                EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                //doWhileOld(StrEbx, EntEax.Str, env.Stack, env.Settings, env.Variables);
                env.doDoWhile(db, trunc(EntEbx.Num), trunc(EntEax.Num));
            end;
            //while (True) do
            //begin
            //    env.Stack := parseOpen(StrEbx, env.Stack, env.Settings, env.Variables);
            //    if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) <> 0) then break;
            //    //doFunction(EntEax, env.Stack, env.Settings, env.Variables);
            //    env.Stack := parseOpen(EntEax.Str, env.Stack, env.Settings, env.Variables);
            //end;
        end; 
        'callUntil' : begin
            if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, TEXP, i)) then Exit; 
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TFUN) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;  
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;  
                EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                env.doUntil(db, trunc(EntEbx.Num), trunc(EntEax.Num));
            end else begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;  
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TEXP, i)) then Exit;  
                EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                env.doDoUntil(db, trunc(EntEbx.Num), trunc(EntEax.Num));
            end;
        end;        

        'break' : begin
            env.Settings.KeepWorking := 0;
        end;
        'continue' : begin
            env.Settings.KeepWorking := 1;
        end;

        'rand' : begin
            z := random();
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'random' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_get(env.Stack[env.Settings.StackPointer]).Num;
            stack_pop(env.Stack[env.Settings.StackPointer]);
            z := random(trunc(y));
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;

        // single operands
        //'scan' : begin
        //    EntEax := scan_value();
        //    stack_push(env.Stack[env.Settings.StackPointer], EntEax);
        //end;
        'scannum' : begin
            EntEax := scan_number();
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            stack_push(env.Stack[env.Settings.StackPointer], EntEax);
        end;
        'scanstr' : begin
            EntEax := scan_string();
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            stack_push(env.Stack[env.Settings.StackPointer], EntEax);
        end;
        //'times' : begin
        //  	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
        //    y := stack_get(env.Stack[env.Settings.StackPointer]).Num;
        //    stack_pop(env.Stack[env.Settings.StackPointer]);
        //    if (y >= 0) then Steps := trunc(y);
        //end;
        //'tilleof' : begin
        //  	Steps := -1;
        //end;
        'clone' : begin
            EntEax := stack_get(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], EntEax);
        end;
        'type' : begin
          	EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
          	stack_push(env.Stack[env.Settings.StackPointer], buildString(getEntityTypeName(EntEax.EntityType)));
        end;
        'swapAt' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            index := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            swapEntities(env.Stack[env.Settings.StackPointer].Values[index-1], env.Stack[env.Settings.StackPointer].Values[index]);
        end;
        'swapAt2' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            index := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            swapEntities(env.Stack[env.Settings.StackPointer].Values[IntEax], env.Stack[env.Settings.StackPointer].Values[index]);
        end;

        // casting types
        'toString' : begin
          	EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (EntEax.EntityType = TVEC) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildString(stack_showArrayPS(env.Stack[trunc(EntEax.Num)], env.Stack, env.Settings.Mask))); 
            end else if (EntEax.EntityType = TNUM) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildString(FormatFloat(env.Settings.Mask, EntEax.Num)));
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], buildString(EntEax.Str));
            end;
        end;
        'toNumber' : begin
            //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            val(EntEax.Str, ExtEax, IntEax); 
            if (IntEax = 0) then begin
             	stack_push(env.Stack[env.Settings.StackPointer], buildNumber(ExtEax));
            end else begin
            	if (env.Settings.StrictType) and (EntEax.EntityType <> TBOO) and (EntEax.EntityType <> TDAT) 
                    then stack_push(env.Stack[env.Settings.StackPointer], buildException('EType:CNonNumeric: Got a non-numeric entity at "toNumber".'))
            	    else stack_push(env.Stack[env.Settings.StackPointer], buildNumber(EntEax.Num));
            end;
        end;
        'toBoolean' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if EntEax.Num = 0 then LogEax := true else LogEax := false;
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(LogEax));
        end;
        'toArray' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            // expection about boundaries
            if (IntEax > stack_size(env.Stack[env.Settings.StackPointer])) then IntEax := stack_size(env.Stack[env.Settings.StackPointer]); 
            stack_push(env.Stack[env.Settings.StackPointer], buildNewArray(env.Stack, env.Settings, IntEax));
        end;
        'makeChar' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(Chr(trunc(y))));
        end;
        'getAscii' : begin
            if (env.Settings.StrictType) and (assertCharLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            StrEcx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(Ord(StrEcx[1])));
        end;
        'isNumber' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if EntEax.EntityType = TNUM 
                then stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(True))
                else stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(False));
        end;
        'isBoolean' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if EntEax.EntityType = TBOO
                then stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(True))
                else stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(False));
        end;
        'isString' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if EntEax.EntityType = TSTR 
                then stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(True))
                else stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(False));
        end;
        'isArray' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if EntEax.EntityType = TVEC 
                then stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(True))
                else stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(False));
        end;
        'isNull' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if EntEax.EntityType = TNIL 
                then stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(True))
                else stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(False));
        end;
        'isException' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if EntEax.EntityType = TEXC 
                then stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(True))
                else stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(False));
        end;
        'isLogicalExpression' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if EntEax.EntityType = TEXP 
                then stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(True))
                else stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(False));
        end;
        'isFunction' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if EntEax.EntityType = TFUN 
                then stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(True))
                else stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(False));
        end;
        'isDateTime' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if EntEax.EntityType = TDAT 
                then stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(True))
                else stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(False));
        end;
        //
        'length' : begin
            if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, TVEC, i)) then Exit; 
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                //IntEax := trunc(stack_get(env.Stack[env.Settings.StackPointer]).Num);
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(stack_size(env.Stack[IntEax])));
            end else begin
                //StrEbx := stack_get(env.Stack[env.Settings.StackPointer]).Str;
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(Length(StrEbx)));
            end;
        end;
        //'print' : begin
        //    EntEax := stack_get(env.Stack[env.Settings.StackPointer]);
        //    if (env.Settings.Autoclear) then stack_pop(env.Stack[env.Settings.StackPointer]);
        //    if (EntEax.EntityType = TBOO) then writeOnConsole(EntEax.Str);
        //    if (EntEax.EntityType = TNUM) then writeOnConsole(FormatFloat(env.Settings.Mask, EntEax.Num));
        //    if (EntEax.EntityType = TSTR) then writeOnConsole(EntEax.Str);
        //    if (EntEax.EntityType = TNIL) then writeOnConsole(EntEax.Str);
        //    if (EntEax.EntityType = TVEC) then writeOnConsole(stack_showArrayPS(env.Stack[trunc(EntEax.Num)], env.Stack, env.Settings.Mask));
        //    if (EntEax.EntityType = TDAT) then writeOnConsole(EntEax.Str);
        //end;
        //'println' : begin
        //    EntEax := stack_get(env.Stack[env.Settings.StackPointer]);
        //    if (env.Settings.Autoclear) then stack_pop(env.Stack[env.Settings.StackPointer]);
        //    if (EntEax.EntityType = TBOO) then writelnOnConsole(EntEax.Str);
        //    if (EntEax.EntityType = TNUM) then writelnOnConsole(FormatFloat(env.Settings.Mask, EntEax.Num));
        //    if (EntEax.EntityType = TSTR) then writelnOnConsole(EntEax.Str);
        //    if (EntEax.EntityType = TNIL) then writelnOnConsole(EntEax.Str);
        //    if (EntEax.EntityType = TVEC) then writelnOnConsole(stack_showArrayPS(env.Stack[trunc(EntEax.Num)], env.Stack, env.Settings.Mask));
        //    if (EntEax.EntityType = TDAT) then writelnOnConsole(EntEax.Str);
        //end;
        'rprint' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (EntEax.EntityType = TBOO) then writeOnConsole(EntEax.Str);
            if (EntEax.EntityType = TNUM) then writeOnConsole(FormatFloat(env.Settings.Mask, EntEax.Num));
            if (EntEax.EntityType = TSTR) then writeOnConsole(EntEax.Str);
            if (EntEax.EntityType = TNIL) then writeOnConsole(EntEax.Str);
            if (EntEax.EntityType = TVEC) then writeOnConsole(stack_showArrayPS(env.Stack[trunc(EntEax.Num)], env.Stack, env.Settings.Mask));
            if (EntEax.EntityType = TDAT) then writeOnConsole(EntEax.Str);
        end;
        'rprintln' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (EntEax.EntityType = TBOO) then writelnOnConsole(EntEax.Str);
            if (EntEax.EntityType = TNUM) then writelnOnConsole(FormatFloat(env.Settings.Mask, EntEax.Num));
            if (EntEax.EntityType = TSTR) then writelnOnConsole(EntEax.Str);
            if (EntEax.EntityType = TNIL) then writelnOnConsole(EntEax.Str);
            if (EntEax.EntityType = TVEC) then writelnOnConsole(stack_showArrayPS(env.Stack[trunc(EntEax.Num)], env.Stack, env.Settings.Mask));
            if (EntEax.EntityType = TDAT) then writelnOnConsole(EntEax.Str);
        end;
        'colprint' : begin
        	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (EntEax.EntityType = TBOO) then write(EntEax.Str : trunc(y));
            if (EntEax.EntityType = TNUM) then write(FormatFloat(env.Settings.Mask, EntEax.Num) : trunc(y));
            if (EntEax.EntityType = TSTR) then write(EntEax.Str : trunc(y));
            if (EntEax.EntityType = TNIL) then write(EntEax.Str : trunc(y));
            if (EntEax.EntityType = TVEC) then write(stack_showArrayPS(env.Stack[trunc(EntEax.Num)], env.Stack, env.Settings.Mask) : trunc(y));
            if (EntEax.EntityType = TDAT) then write(EntEax.Str : trunc(y));
        end;
        'colprintln' : begin
        	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (EntEax.EntityType = TNUM) then writeln(FormatFloat(env.Settings.Mask, EntEax.Num) : trunc(y));
            if (EntEax.EntityType = TSTR) then writeln(EntEax.Str : trunc(y));
            if (EntEax.EntityType = TNIL) then writeln(EntEax.Str : trunc(y));
            if (EntEax.EntityType = TBOO) then writeln(EntEax.Str : trunc(y));
            if (EntEax.EntityType = TVEC) then writeln(stack_showArrayPS(env.Stack[trunc(EntEax.Num)], env.Stack, env.Settings.Mask) : trunc(y));
            if (EntEax.EntityType = TDAT) then writeln(EntEax.Str : trunc(y));
        end;
        'newln' : begin
            writelnOnConsole('');
        end;
        'status' : begin
            writeOnConsole(stack_show(env.Stack[env.Settings.StackPointer], env.Settings.Mask));
        end;
        'statusln' : begin
            writelnOnConsole(stack_show(env.Stack[env.Settings.StackPointer], env.Settings.Mask));
        end;
        'autocolstatus' : begin
            writeOnConsole(stack_showBeautiful(env.Stack[env.Settings.StackPointer], env.Settings.Mask));
        end;
        'autocolstatusln' : begin
            writelnOnConsole(stack_showBeautiful(env.Stack[env.Settings.StackPointer], env.Settings.Mask));
        end;
        'statusfull' : begin
            writelnOnConsole(stack_showFull(env.Stack[env.Settings.StackPointer]));
        end;
        'getchar' : begin
            readln();
        end;
        //'rem' : begin
        //	stack_justpop(env.Stack[env.Settings.StackPointer]);
        //end;
        'frontrem' : begin
        	stack_justpopFront(env.Stack[env.Settings.StackPointer], 0);
        end;
        //'qshift' : begin
        //	stack_push(env.Stack[env.Settings.StackPointer], stack_firstpop(env.Stack[env.Settings.StackPointer]));
        //end;
        'clear' : begin
        	stack_clear(env.Stack[env.Settings.StackPointer]);
        end;
        'keep' : begin
          	if (env.Settings.StrictType) and (assertPositiveNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
          	y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
          	SetLength(HelpETable, trunc(y));
          	for index := 0 to trunc(y)-1 do HelpETable[index] := stack_pop(env.Stack[env.Settings.StackPointer]);
          	stack_clear(env.Stack[env.Settings.StackPointer]);
          	for index := trunc(y)-1 downto 0 do stack_push(env.Stack[env.Settings.StackPointer], HelpETable[index]);
          	SetLength(HelpETable, 0);
        end;
        'copy' : begin
          	if (env.Settings.StrictType) and (assertPositiveNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_get(env.Stack[env.Settings.StackPointer]).Num;
            stack_pop(env.Stack[env.Settings.StackPointer]);
            SetLength(HelpETable, trunc(y));
            for index := 0 to trunc(y)-1 do HelpETable[index] := stack_pop(env.Stack[env.Settings.StackPointer]);
            for index := trunc(y)-1 downto 0 do stack_push(env.Stack[env.Settings.StackPointer], HelpETable[index]);
            for index := trunc(y)-1 downto 0 do stack_push(env.Stack[env.Settings.StackPointer], HelpETable[index]);
            SetLength(HelpETable, 0);
        end;
        'mcopy' : begin
          	if (env.Settings.StrictType) and (assertPositiveNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
          	y := stack_get(env.Stack[env.Settings.StackPointer]).Num;
          	stack_pop(env.Stack[env.Settings.StackPointer]);
          	SetLength(HelpETable, trunc(y));
          	for index := 0 to trunc(y)-1 do begin
          		HelpETable[index] := stack_get(env.Stack[env.Settings.StackPointer]);
          		stack_pop(env.Stack[env.Settings.StackPointer]);
          	end;
          	for index := trunc(y)-1 downto 0 do stack_push(env.Stack[env.Settings.StackPointer], HelpETable[index]);
          	for index := 0 to trunc(y)-1 do stack_push(env.Stack[env.Settings.StackPointer], HelpETable[index]);
          	SetLength(HelpETable, 0);
        end;
        'sort' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TNUM) then
            begin
                //if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                size := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                if (size >= 0) then
                begin
                    SetLength(HelpETable, size);
                    HelpETable := stack_popCollection(env.Stack[env.Settings.StackPointer], size);
                    if (env.Settings.sorttype = 0) then bubblesort(HelpETable);
                    if (env.Settings.sorttype = 1) then quicksort(HelpETable);
                    if (env.Settings.sorttype = 2) then mergesort(HelpETable);
                    if (env.Settings.sorttype = 3) then bogosort(HelpETable);
                    stack_pushCollection(env.Stack[env.Settings.StackPointer], HelpETable);
                    SetLength(HelpETable, 0);
                end;
            end else Found := false;
        end;
        'numsort' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            size := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (size >= 0) then
            begin
                SetLength(HelpETable, size);
                HelpETable := stack_popCollection(env.Stack[env.Settings.StackPointer], size);
                if (env.Settings.sorttype = 0) then bubblesort(HelpETable);
                if (env.Settings.sorttype = 1) then quicksort(HelpETable);
                if (env.Settings.sorttype = 2) then mergesort(HelpETable);
                if (env.Settings.sorttype = 3) then bogosort(HelpETable);
                stack_pushCollection(env.Stack[env.Settings.StackPointer], HelpETable);
                SetLength(HelpETable, 0);
            end;
        end;
		'strsort' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            size := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (size >= 0) then
            begin
                SetLength(HelpETable, size);
                HelpETable := stack_popCollection(env.Stack[env.Settings.StackPointer], size);
                strings_sort(HelpETable);
                stack_pushCollection(env.Stack[env.Settings.StackPointer], HelpETable);
                SetLength(HelpETable, 0);
            end;
        end;
        'reverse' : begin
            env.Stack[env.Settings.StackPointer] := stack_reverse(env.Stack[env.Settings.StackPointer]);
        end;
        'rev' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            size := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (size >= 0) then stack_reverseCollection(env.Stack[env.Settings.StackPointer], size);
        end;
        'swap' : begin
            stack_reverseCollection(env.Stack[env.Settings.StackPointer], 2);
        end;             


        // stack operands
        'sum' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
          	size := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
          	if (size >= 0) then
            begin
                SetLength(HelpETable, size);
                HelpETable := stack_popCollection(env.Stack[env.Settings.StackPointer], size);
                ExtEax := table_sum(HelpETable);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(ExtEax));
                SetLength(HelpETable, 0);
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(0.0));
            end;
        end;
        'product' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            size := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (size >= 0) then
            begin
                SetLength(HelpETable, size);
                HelpETable := stack_popCollection(env.Stack[env.Settings.StackPointer], size);
                ExtEax := table_product(HelpETable);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(ExtEax));
                SetLength(HelpETable, 0);
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(1.0));
            end;
        end;
        'count' : begin
          	z := 0.0;
          	while (stack_size(env.Stack[env.Settings.StackPointer]) > 0) do
          	begin
          		z := z + 1;
          		stack_justpop(env.Stack[env.Settings.StackPointer]);
          	end;
          	stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'size' : begin
          	z := stack_size(env.Stack[env.Settings.StackPointer]);
          	stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'all' : begin
          	z := stack_size(env.Stack[env.Settings.StackPointer]);
          	stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'avg' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            size := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (size >= 0) then
            begin
                SetLength(HelpETable, size);
                HelpETable := stack_popCollection(env.Stack[env.Settings.StackPointer], size);
                ExtEax := table_avg(HelpETable);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(ExtEax));
                SetLength(HelpETable, 0);
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(0.0));
            end;
        end;
        'mean' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            size := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (size >= 0) then
            begin
                SetLength(HelpETable, size);
                HelpETable := stack_popCollection(env.Stack[env.Settings.StackPointer], size);
                ExtEax := table_avg(HelpETable);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(ExtEax));
                SetLength(HelpETable, 0);
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(0.0));
            end;
        end;
        'min' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            size := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (size >= 0) then
            begin
                SetLength(HelpETable, size);
                HelpETable := stack_popCollection(env.Stack[env.Settings.StackPointer], size);
                ExtEax := table_min(HelpETable);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(ExtEax));
                SetLength(HelpETable, 0);
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNull());
            end;
        end;
        'max' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            size := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (size >= 0) then
            begin
                SetLength(HelpETable, size);
                HelpETable := stack_popCollection(env.Stack[env.Settings.StackPointer], size);
                ExtEax := table_max(HelpETable);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(ExtEax));
                SetLength(HelpETable, 0);
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNull());
            end;
        end;
        'median' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            size := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (size >= 0) then
            begin
                SetLength(HelpETable, size);
                HelpETable := stack_popCollection(env.Stack[env.Settings.StackPointer], size);
                ExtEax := table_median(HelpETable);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(ExtEax));
                SetLength(HelpETable, 0);
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNull());
            end;
        end;
        'variance' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            size := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (size >= 0) then
            begin
                SetLength(HelpETable, size);
                HelpETable := stack_popCollection(env.Stack[env.Settings.StackPointer], size);
                ExtEax := table_variance(HelpETable);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(ExtEax));
                SetLength(HelpETable, 0);
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNull());
            end;
        end;
        'stddev' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            size := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (size >= 0) then
            begin
                SetLength(HelpETable, size);
                HelpETable := stack_popCollection(env.Stack[env.Settings.StackPointer], size);
                ExtEax := table_stddev(HelpETable);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(sqrt(ExtEax)));
                SetLength(HelpETable, 0);
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNull());
            end;
          end;
             
        // stack creators
        'seq' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
          	z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
          	y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (x <= z) then
            begin
            	while (x <= z) do 
            	begin
                    //checkSIGINT();
            		stack_push(env.Stack[env.Settings.StackPointer], buildNumber(x));
            		x := x + y;
            	end;
            end else begin
            	while (x >= z) do 
            	begin
                    //checkSIGINT();
            		stack_push(env.Stack[env.Settings.StackPointer], buildNumber(x));
            		x := x - y;
            	end;
            end;
        end;
        'seql' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            a := 1.0;
          	while (a <= z) do 
            begin
                //checkSIGINT();
            	stack_push(env.Stack[env.Settings.StackPointer], buildNumber(x));
            	x := x + y;
            	a := a + 1.0;
            end;
        end;
        'gseq' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (x <= z) then
            begin
              while (x <= z) do 
              begin
                //checkSIGINT();
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(x));
                x := x * y;
              end;
            end else begin
              while (x >= z) do 
              begin
                //checkSIGINT();
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(x));
                x := x / y;
              end;
            end;
        end;
        'gseql' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            a := 1.0;
          	while (a <= z) do 
            begin
                //checkSIGINT();
            	stack_push(env.Stack[env.Settings.StackPointer], buildNumber(x));
            	x := x * y;
            	a := a + 1.0;
            end;
        end;

        else begin
            Found := false;
            {*
            case LeftStr(i, 1) of
            	'X' : begin
              		if (RightStr(i, Length(i)-1) = '*') and (not (Unit5.is_gui)) then Steps := -1
              		else if (RightStr(i, Length(i)-1) <> '') then Steps := StrToInt(RightStr(i, Length(i)-1))
                    else stack_push(env.Stack[env.Settings.StackPointer], buildString('X'));
              	end;
              	else begin
                	Found := false;
              	end;
            end;
            *}
        end;
    end;
    lib_ultravanilla := Found;
end;

function lib_math(i : String; var env : PSEnvironment; var db : PSCommandDB) : Boolean;
var
	Found        : Boolean;
	x, y, z, w   : Extended;
    index, jndex : LongInt;
    ArrEax       : Entity;
begin
	Found := true;
	case i of

		// binary
		'Math.choose' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (x = trunc(x)) then begin
                z := newton_int(x,y);
            end else begin
                z := newton_real(x,y);
            end;
        	stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.gcd' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := gcd(x, y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.lcm' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := lcm(x, y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
		'Math.fibonacci' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := fib(trunc(y)); 
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;

        // Trigonometrics

        'Math.sin' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := sin(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.cos' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := cos(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.csc' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := 1/sin(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.sec' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := 1/cos(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.tan' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := sin(y)/cos(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.cot' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := cos(y)/sin(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.arcsin' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := arcsin(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.arccos' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := arccos(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.arctan' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := arctan(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.arccot' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := PI/2-arctan(y);
            
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.arcsec' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := 1.0 / y;
            z := arccos(z);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.arccsc' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := 1.0 / y;
            z := arcsin(z);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.sinh' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := sinh(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.cosh' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := cosh(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.csch' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := 1/sinh(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.sech' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := 1/cosh(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.tanh' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := sinh(y)/cosh(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.coth' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := cosh(y)/sinh(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.arsinh' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := arsinh(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.arcosh' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := arcosh(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.artanh' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := artanh(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.arcoth' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := 0.5*ln((y+1)/(y-1));
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.arsech' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := ln((1 + sqrt(1 - y*y)) / y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.arcsch' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := ln(1.0/y + sqrt(1.0/(y*y) + 1));
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.toRadians' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := degtorad(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.toDegrees' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := radtodeg(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;


        // constants
		'Math.PI' : begin
          stack_push(env.Stack[env.Settings.StackPointer], buildNumber(PI));
        end;
        'Math.EU' : begin
          stack_push(env.Stack[env.Settings.StackPointer], buildNumber(EU));
        end;
        'Math.FI' : begin
          stack_push(env.Stack[env.Settings.StackPointer], buildNumber(FI));
        end;
		'Math.EM' : begin
          stack_push(env.Stack[env.Settings.StackPointer], buildNumber(EM));
        end;

        // Statistics
		'Math.gamma' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := vgamma(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.gammaln' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := LogGamma(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
		'Math.distNormStd' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := dstdnorm(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.funcNormStd' : begin
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := fnorm(x, 0, 1);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.randomNormStd' : begin
            z := randg(0, 1);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.genNormStd' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            for index := 1 to trunc(x) do
            begin
                //checkSIGINT();
                w := randg(0, 1);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
            end;
        end;
		'Math.distNorm' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := dnorm(x, y, z);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.funcNorm' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := fnorm(x, y, z);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.randomNorm' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := randg(x, y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.genNorm' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            for index := 1 to trunc(x) do
            begin
                //checkSIGINT();
                w := randg(y, z);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
            end;
        end;
        'Math.randomBinom' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := rbinom(trunc(y), z);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.genBinom' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            for index := 1 to trunc(x) do
            begin
                w := rbinom(trunc(y), z);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
            end;
        end;
        'Math.funcBinom' : begin
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := fbinom(trunc(y), trunc(x), z);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.distBinom' : begin
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := dbinom(trunc(y), trunc(x), z);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;

        'Math.funcGeom' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertPositiveNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := fgeom(trunc(x), y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.distGeom' : begin
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertPositiveNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := dgeom(trunc(x), y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.randomGeom' : begin
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := rgeom(x);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.genGeom' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            for index := 1 to trunc(x) do
            begin
                w := rgeom(y);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
            end;            
        end;

        'Math.funcExp' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := fexp(x, y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.distExp' : begin
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := dexp(x, y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.randomExp' : begin
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := rexp(x);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.genExp' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            for index := 1 to trunc(x) do
            begin
                w := rexp(y);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
            end;
        end;
        'Math.funcPoisson' : begin
            if (env.Settings.StrictType) and (assertPositiveNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := fpoisson(trunc(x), trunc(y));
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.distPoisson' : begin
			if (env.Settings.StrictType) and (assertPositiveNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := dpoisson(trunc(x), trunc(y));
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.randomPoisson' : begin
			if (env.Settings.StrictType) and (assertPositiveNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := rpoisson(trunc(x));
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.genPoisson' : begin
            if (env.Settings.StrictType) and (assertPositiveNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            for index := 1 to trunc(x) do
            begin
                w := rpoisson(trunc(y));
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
            end;
        end;
        'Math.funcGamma' : begin
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := fgamma(x, y, z);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.distGamma' : begin
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := dgamma(x, y, z);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.randomGamma' : begin
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            //z := rgamma1(x, y);
            z := rgengamma(0, 1/y, x);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.genGamma' : begin
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            for index := 1 to trunc(x) do
            begin
                //checkSIGINT();
                //w := rgengamma(1/z, y, 1);
                //w := rgamma1(y, z);
                w := rgengamma(0, 1/z, y);
                //w := rgengamma(z, y, 1);
                // do poprawki
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
            end;
        end;
        'Math.funcChiSq' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := fgamma(x, y/2, 0.5);
            //w := fchisq(x, trunc(y));
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.distChiSq' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := dgamma(x, y/2, 0.5);
            //w := dchisq(x, trunc(y));
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.randomChiSq' : begin
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            //if ftrunc(x) = 1 
            //    then z := rgamma1(x/2, 0.5)
            //    else z := rgengamma(0, 2, x/2);
            z := rchisq(x);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.genChiSq' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            for index := 1 to trunc(x) do
            begin
                //checkSIGINT();
                //w := rgengamma(1/z, y, 1);
                //if ftrunc(y) = 1 
                //    then w := rgamma1(y/2, 0.5)
                //    else w := rgengamma(0, 2, y/2);
                w := rchisq(y);
                // do poprawki
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
            end;
        end;
        'Math.funcErlang' : begin
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := ferlang(x, y, z);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.distErlang' : begin
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := derlang(x, y, z);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.randomErlang' : begin
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            //z := rgamma1(x, y);
            //z := rgengamma(0, 1/y, x);
            z := rerlang(x, y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.genErlang' : begin
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            for index := 1 to trunc(x) do
            begin
                //checkSIGINT();
                //w := rgengamma(1/z, y, 1);
                //w := rgamma1(y, z);
                //w := rgengamma(0, 1/z, y);
                w := rerlang(y, z);
                //w := rgengamma(z, y, 1);
                // do poprawki
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
            end;
        end;

        'Math.funcT' : begin
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            //w := fgamma(x, y/2, 0.5);
            w := fstudentt(x, y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.distT' : begin
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            //w := dgamma(x, y/2, 0.5);
            w := dstudentt(x, y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.randomT' : begin
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := rstudentt(x);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.genT' : begin
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            for index := 1 to trunc(x) do
            begin
                w := rstudentt(y);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
            end;
        end;
        'Math.funcBeta' : begin
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := fbeta(x, y, z);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.distBeta' : begin
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := dbeta(x, y, z);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.randomBeta' : begin
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := rbeta(x, y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.genBeta' : begin
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            for index := 1 to trunc(x) do
            begin
                //checkSIGINT();
                //w := rgengamma(1/z, y, 1);
                //w := rgamma1(y, z);
                w := rbeta(y, z);
                //w := rgengamma(z, y, 1);
                // do poprawki
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
            end;
        end;
        'Math.funcF' : begin
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := ffischerf(x, y, z);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.distF' : begin
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := dfischerf(x, y, z);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.randomF' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := rfischerf(x, y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.genF' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            for index := 1 to trunc(x) do
            begin
                w := rfischerf(y, z);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
            end;
        end;
        'Math.funcArcsine' : begin
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := farcsine(x);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.distArcsine' : begin
			if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := darcsine(x);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.randomArcsine' : begin
            z := rarcsine();
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Math.genArcsine' : begin
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            for index := 1 to trunc(x) do
            begin
                w := rarcsine();
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
            end;
        end;

        'Math.moment' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            index := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_moment(env.Stack[trunc(ArrEax.Num)].Values, index)));
        end;
        'Math.quantile' : begin
            if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (x >= 0) and (x <= 1) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_quantile(env.Stack[trunc(ArrEax.Num)].Values, x)));
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], raiseNumRangeConstraint(i, 0, 1));
            end;
        end;
        'Math.tertile' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (x >= 0) and (x <= 3) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_quantile2(env.Stack[trunc(ArrEax.Num)].Values, x, 3)));
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], raiseNumRangeConstraint(i, 0, 3));
            end;
        end;
        'Math.quartile' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (x >= 0) and (x <= 4) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_quantile2(env.Stack[trunc(ArrEax.Num)].Values, x, 4)));
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], raiseNumRangeConstraint(i, 0, 4));
            end;
        end;
        'Math.octile' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (x >= 0) and (x <= 8) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_quantile2(env.Stack[trunc(ArrEax.Num)].Values, x, 8)));
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], raiseNumRangeConstraint(i, 0, 8));
            end;
        end;
        'Math.decile' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (x >= 0) and (x <= 10) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_quantile2(env.Stack[trunc(ArrEax.Num)].Values, x, 10)));
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], raiseNumRangeConstraint(i, 0, 10));
            end;
        end;
        'Math.hexadecile' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (x >= 0) and (x <= 16) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_quantile2(env.Stack[trunc(ArrEax.Num)].Values, x, 16)));
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], raiseNumRangeConstraint(i, 0, 16));
            end;
        end;
        'Math.percentile' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (x >= 0) and (x <= 100) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_quantile2(env.Stack[trunc(ArrEax.Num)].Values, x, 100)));
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], raiseNumRangeConstraint(i, 0, 100));
            end;
        end;
        'Math.skewness' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_skewness(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Math.kurtosis3' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_kurtosis(env.Stack[trunc(ArrEax.Num)].Values)-3));
        end;
        'Math.excessKurtosis' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_kurtosis(env.Stack[trunc(ArrEax.Num)].Values)-3));
        end;
        'Math.kurtosis' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_kurtosis(env.Stack[trunc(ArrEax.Num)].Values)));
        end;


        // Number Theory
        'Math.genNaturalDivisors' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            index := 1;
            while (index*index <= x) do
            begin
                if (divides(ftrunc(x), index)) then 
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], buildNumber(index));
                    if (index*index <> x) then stack_push(env.Stack[env.Settings.StackPointer], buildNumber(x/index));
                end;
                index := index + 1;
            end;
        end;
        'Math.genDivisors' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            index := 1;
            while (index*index <= x) do
            begin
                if (divides(ftrunc(x), index)) then 
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], buildNumber(index));
                    stack_push(env.Stack[env.Settings.StackPointer], buildNumber(-index));
                    if (index*index <> x) then begin 
                        stack_push(env.Stack[env.Settings.StackPointer], buildNumber(x/index));
                        stack_push(env.Stack[env.Settings.StackPointer], buildNumber(-x/index));
                    end;
                end;
                index := index + 1;
            end;
        end;
        'Math.divides' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(divides(x, y)));
        end;
        'Math.countNaturalDivisors' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(num_tau(x)));
        end;
        'Math.sumNaturalDivisors' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(num_sigma(x)));
        end;
        'Math.fTau' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(num_tau(x)));
        end;
        'Math.fSigma' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(num_sigma(x)));
        end;
        'Math.fMobius' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(num_mobius(x)));
        end;
        'Math.fMu' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(num_mobius(x)));
        end;
        'Math.fEuler' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(num_euler(x)));
        end;
        'Math.fPhi' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(num_euler(x)));
        end;
        'Math.fPi' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(num_pi(x)));
        end;
        //'Math.factorize' : begin
        //    if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
        //    x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
        //    
        //    index := trunc(x);
        //    while (index > 1) do
        //    begin
        //        jndex := 2;
        //        while not (divides(index, jndex)) do jndex := jndex + 1;
        //        stack_push(env.Stack[env.Settings.StackPointer], buildNumber(jndex));
        //        index := index div jndex;
        //    end;
        //end;
        'Math.primeDistribution' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            while (x > 1) do
            begin
                if (isPrime(x)) then
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], buildNumber(x));
                    //stack_push(env.Stack[env.Settings.StackPointer], buildNumber(1));
                    x := 1;
                end else begin
                    y := 2;
                    while not (divides(x, y)) do y := y + 1;
                    stack_push(env.Stack[env.Settings.StackPointer], buildNumber(y));
                    x := x / y;
                end;
            end;
        end;
        'Math.leastPrimeDivisor' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (isPrime(x)) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(x));
            end else begin
                y := 2;
                while not (divides(x, y)) do y := y + 1;
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(y));
            end;
        end;
        'Math.factorize' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (isPrime(x)) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(x));
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(1));
            end else begin
                y := 2;
                while not (divides(x, y)) do y := y + 1;
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(y));
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(x/y));
            end;
        end;
        'Math.randomIntRange' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (x < y) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(randomIntRange(x, y)));
            end else if (x = y) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(x));
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(randomIntRange(y, x)));
            end;
        end;
        'Math.randomRealRange' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (x < y) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(randomRealRange(x, y)));
            end else if (x = y) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(NaN));
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(randomRealRange(y, x)));
            end;
        end;
        'Math.euclidean' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := gcdExtended(trunc(x), trunc(y), index, jndex);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(index));
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(jndex));
        end;
        'Math.bezoutCoefs' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := gcdExtended(trunc(x), trunc(y), index, jndex);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(index));
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(jndex));
        end;
        'Math.erf' : begin
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := ferf(x);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.erfc' : begin
			if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            w := ferfc(x);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(w));
        end;
        'Math.fomega' : begin
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(num_omega(x)));
        end;
        'Math.fOmega' : begin
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(num_omega2(x)));
        end;
        'Math.countDistinctFactors' : begin
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(num_omega(x)));
        end;
        'Math.countAllFactors' : begin
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(num_omega2(x)));
        end;
        'Math.fLambda' : begin
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(num_liouville(x)));
        end;
        'Math.fLiouville' : begin
			if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(num_liouville(x)));
        end;
        'Math.isSquareFree' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(num_isSquareFree(y)));
        end;
        'Math.modularPower' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(modularPower(trunc(x), trunc(y), trunc(z))));
        end;
        'Math.modPower' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(modularPower(trunc(x), trunc(y), trunc(z))));
        end;
        'Math.modPow' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            z := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(modularPower(trunc(x), trunc(y), trunc(z))));
        end;
        'Math.modularInverse' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(modularInverse(trunc(x), trunc(y))));
        end;
        'Math.modularMulInverse' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(modularInverse(trunc(x), trunc(y))));
        end;
        'Math.modMulInv' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(modularInverse(trunc(x), trunc(y))));
        end;
        'Math.coprimes' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(gcd(x, y) = 1));
        end;
        'Math.isCarmichael' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(num_isCarmichael(trunc(y))));
        end;

		else begin
            Found := false;
        end;
	end;
	lib_math := Found;
end;

function lib_strings(i : String; var env : PSEnvironment; var db : PSCommandDB) : Boolean;
var
	Found          : Boolean;
	x, y           : Extended;
	index          : Longint;
	IntEax, IntEbx : LongInt;
	StrEax, StrEbx : String;
	StrEcx, StrEdx : String;
	ExtEax         : Extended;
    EntEax, EntEbx : Entity;
	HelpTStrings   : TStrings;
    HelpSTable     : array of String;
begin
	Found := true;
	case i of
		'String.concat' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(concat(StrEax, StrEbx)));
        end;
        'String.join' : begin
            if  (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) 
            and (stack_getback(env.Stack[env.Settings.StackPointer], 1).EntityType = TSTR) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(concat(StrEax, StrEbx)));
            end else Found := false;
        end;
        'String.crush' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TSTR) then
            begin
                SetLength(HelpSTable, 0);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                IntEbx := 1;
                while (IntEbx <= Length(StrEbx)) do begin
                	SetLength(HelpSTable, IntEbx+1);
                	HelpSTable[IntEbx] := Copy(StrEbx, IntEbx, 1);
                	IntEbx := IntEbx + 1; 
                end;
                for index := 1 to Length(HelpSTable)-1 do stack_push(env.Stack[env.Settings.StackPointer], buildString(HelpSTable[index])); 
                SetLength(HelpSTable, 0);
            end else Found := false;
        end;
        'String.crushBy' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
          	    if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
                y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                IntEax := 1;
                IntEbx := 1;
                SetLength(HelpSTable, 0);
                while (IntEax <= Length(StrEbx)) do begin
                	SetLength(HelpSTable, IntEbx+1);
                	HelpSTable[IntEbx] := Copy(StrEbx, IntEax, trunc(y));
                	IntEax := IntEax + trunc(y);
                	IntEbx := IntEbx + 1; 
                end;
                for index := 1 to Length(HelpSTable)-1 do stack_push(env.Stack[env.Settings.StackPointer], buildString(HelpSTable[index])); 
                SetLength(HelpSTable, 0);
            end else Found := false;
        end;
        'String.left' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
          	    if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
                y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(LeftStr(StrEbx, trunc(y))));
            end else Found := false;
        end;
        'String.right' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
          	    if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(RightStr(StrEbx, trunc(y))));
            end else Found := false;
        end;
        'String.trim' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(Trim(StrEbx)));
            end else Found := False;
        end;
        'String.trimLeft' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(TrimLeft(StrEbx)));
            end else Found := False;
        end;
        'String.trimRight' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(TrimRight(StrEbx)));
            end else Found := False;
        end;
        'String.trimChars' : begin
            if (env.Settings.StrictType) and (assertCharLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(TrimChars(StrEbx, StrEax[1])));
        end;
        'String.trimCharsLeft' : begin
            if (env.Settings.StrictType) and (assertCharLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(TrimCharsLeft(StrEbx, StrEax[1])));
        end;
        'String.trimCharsRight' : begin
            if (env.Settings.StrictType) and (assertCharLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(TrimCharsRight(StrEbx, StrEax[1])));
        end;
        'String.padLeft' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
        	    if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(PadLeft(StrEbx, trunc(y))));
            end else Found := False;
        end;
        'String.padRight' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(PadRight(StrEbx, trunc(y))));
            end else Found := False;
        end;
        'String.pad' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(PadCenter(StrEbx, trunc(y))));
            end else Found := False;
        end;
        'String.padCharsLeft' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertCharLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            //StrEcx := AddChar(StrEax[1], StrEbx, trunc(y));
            //stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEcx));
            stack_push(env.Stack[env.Settings.StackPointer], buildString(AddChar(StrEax[1], StrEbx, trunc(y))));
        end;
        'String.padCharsRight' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertCharLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            //StrEcx := AddCharR(StrEax[1], StrEbx, trunc(y));
            //stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEcx));
            stack_push(env.Stack[env.Settings.StackPointer], buildString(AddCharR(StrEax[1], StrEbx, trunc(y))));
        end;
        'String.padChars' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertCharLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(PadCharsCenter(StrEbx, trunc(y), StrEax[1])));
        end;
        'String.despace' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(DelChars(StrEbx, ' ')));
        end;
        'String.onespace' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(DelSpace1(StrEbx)));
        end;
        'String.dechar' : begin
            if (env.Settings.StrictType) and (assertCharLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            StrEcx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEcx));
        end;
        'String.bind' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax + ' ' + StrEbx));
        end;
        'String.bindBy' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEcx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax + StrEcx + StrEbx));
        end;
        'String.splitBySpace' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str; 
            HelpTStrings := TStringlist.Create;
            HelpTStrings.Delimiter := ' ';
            HelpTStrings.QuoteChar := '"';
            HelpTStrings.StrictDelimiter := false;
            HelpTStrings.DelimitedText := StrEbx;
            for StrEax in HelpTStrings do stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax)); 
            HelpTStrings.Free;
        end;
        'String.splitBy' : begin
            if (env.Settings.StrictType) and (assertCharLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            StrEcx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;   
            HelpTStrings := TStringlist.Create;
            HelpTStrings.Delimiter := StrEcx[1];
            HelpTStrings.QuoteChar := '"';
            HelpTStrings.StrictDelimiter := false;
            HelpTStrings.DelimitedText := StrEbx;
            for StrEax in HelpTStrings do stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax)); 
            HelpTStrings.Free;
        end;
        'String.splitByExpression' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TEXP, TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                StrEbx := '';
                StrEcx := '';
                env.Variables.addLayer();
                if (EntEax.EntityType = TFUN) then
                begin
                    for index := 1 to Length(StrEax) do
                    begin
                        stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                        env.doFunction(trunc(EntEax.Num));
                        if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) = 0) 
                            then StrEbx := StrEbx + StrEax[index]
                            else StrEcx := StrEcx + StrEax[index];
    		        end;
                end else begin
                    for index := 1 to Length(StrEax) do
                    begin
                        stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                        env.doFunction(trunc(EntEax.Num));
                        if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) = 0) 
                            then StrEbx := StrEbx + StrEax[index]
                            else StrEcx := StrEcx + StrEax[index];
    		        end;
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEcx));
            end else Found := False;
        end;
        'String.substring' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num +1-env.Settings.StringStart;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(Copy(StrEbx, trunc(x), trunc(y)))); 
        end;
        'String.between' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TSTR) then
            begin
          	    if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                y := stack_pop(env.Stack[env.Settings.StackPointer]).Num +1-env.Settings.StringStart;
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                x := stack_pop(env.Stack[env.Settings.StackPointer]).Num +1-env.Settings.StringStart;
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(Copy(StrEbx, trunc(x), trunc(y)-trunc(x)+1))); 
            end else Found := false;
        end;
        'String.positionFirst' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(Pos(StrEbx, StrEax) -1+env.Settings.StringStart)); 
        end;
        'String.remove' : begin 
          	if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TSTR) then
          	begin
          	  	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
              	StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
              	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
              	StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                Delete(StrEax, Pos(StrEbx, StrEax), Length(StrEbx));
              	stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax)); 
          	end else begin
          	  	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
              	y := stack_pop(env.Stack[env.Settings.StackPointer]).Num; // check
          	  	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
              	x := stack_pop(env.Stack[env.Settings.StackPointer]).Num +1-env.Settings.StringStart;
              	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
              	StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                Delete(StrEax, trunc(x), trunc(y)); 
              	stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax));
          	end;
        end;
        'String.insert' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num +1-env.Settings.StringStart;
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            Insert(StrEbx, StrEax, trunc(y));
            stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax)); 
        end;
        'String.replace' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num +1-env.Settings.StringStart;
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            Delete(StrEax, Length(StrEbx), trunc(y)); 
            Insert(StrEbx, StrEax, trunc(y));
            stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax)); 
        end;
        'String.nthOccur' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(NPos(StrEbx, StrEax, trunc(y)) -1+env.Settings.StringStart)); 
        end;
        'String.positionFrom' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num +1-env.Settings.StringStart;
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(PosEx(StrEbx, StrEax, trunc(y)) -1+env.Settings.StringStart)); 
        end;
		'String.positionLast' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(LastDelimiter(StrEbx, StrEax) -1+env.Settings.StringStart)); 
        end;
        'String.occurs' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(OccurrencesOfSubstring(StrEax, StrEbx))); 
        end;
        'String.eval' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            env.executePSCode(StrEbx);
        end;
		'String.length' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TSTR) then
            begin
          	    //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(Length(StrEax)));
            end else Found := false;
        end;
        'String.value' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            val(StrEax, ExtEax, IntEax); 
            if (IntEax = 0) then begin
              stack_push(env.Stack[env.Settings.StackPointer], buildNumber(ExtEax));
            end else begin
              stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax));
            end;
        end;
		'String.inC' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            StrEcx := string_fromC(StrEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEcx));
        end;
        //
        'String.cutLeft' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
          	    if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
                y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                StrEax := RightStr(StrEbx, Length(StrEbx)-trunc(y));
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax));
            end else Found := false;
        end;
        'String.cutRight' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
          	    if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                StrEax := LeftStr(StrEbx, Length(StrEbx)-trunc(y));
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax));
            end else Found := false; 
        end;
        'String.cutBothSides' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TSTR) then
            begin
          	    if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                //stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, Length(env.Stack[trunc(ArrEcx.Num)].Values)-IntEax-IntEbx));
                StrEax := Copy(StrEbx, trunc(x)+1, Length(StrEbx)-trunc(y)-trunc(x));
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax)); 
            end else Found := false; 
        end;
        'String.lower' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(LowerCase(StrEbx)));
        end;
        'String.upper' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(UpperCase(StrEbx)));
        end;
        'String.uplower' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            StrEcx := LowerCase(StrEbx);
            if Length(StrEcx) > 0 then StrEcx[1] := capitalize(StrEcx[1]);
            stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEcx));
        end;
        'String.setAt' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TSTR) then
            begin
          	    if (env.Settings.StrictType) and (assertCharLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                y := stack_pop(env.Stack[env.Settings.StackPointer]).Num +1-env.Settings.StringStart;
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                //StrEcx := StrEax;
                //StrEcx[trunc(y)] := StrEbx[1];
                //stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEcx)); 
                StrEax[trunc(y)] := StrEbx[1];
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax)); 
            end else Found := false; 
        end;
        'String.getAt' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                y := stack_pop(env.Stack[env.Settings.StackPointer]).Num +1-env.Settings.StringStart;
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                StrEbx := Copy(StrEax, trunc(y), 1);
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx)); 
            end else Found := false; 
        end;
        'String.compare' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(CompareStr(StrEax, StrEbx)));
        end;
        'String.split' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                x := stack_pop(env.Stack[env.Settings.StackPointer]).Num +1-env.Settings.StringStart;
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                StrEax := LeftStr(StrEbx, trunc(x)-1);
                StrEcx := RightStr(StrEbx, Length(StrEbx)-trunc(x)+1);
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax)); 
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEcx));
            end else Found := false; 
        end;
        'String.apostrophed' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(quoteRaw(StrEax, '''')));
        end;
        'String.quoted' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(quoteRaw(StrEax, '"')));
        end;
        'String.apostrophed2' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(QuotedStr(StrEax)));
        end;
        'String.quoted2' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(AnsiQuotedStr(StrEax, '"')));
        end;
        'String.enclosed' : begin
            //if (env.Settings.StrictType) and (assertCharLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            case Length(StrEax) of
                0 : stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
                1 : stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[1] + StrEbx + StrEax[1]));
                2 : stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[1] + StrEbx + StrEax[2]));
                else stack_push(env.Stack[env.Settings.StackPointer], raiseStringMaxLength(i, StrEax, 2));
            end;
        end;
        'String.map' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                StrEbx := '';
                env.Variables.addLayer();
                for index := 1 to Length(StrEax) do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                    env.doFunction(trunc(EntEax.Num));
                    StrEbx := StrEbx + stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
            end else Found := False;
        end;
        'String.filter' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TEXP, TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                StrEbx := '';
                env.Variables.addLayer();
                if (EntEax.EntityType = TFUN) then
                begin
                    for index := 1 to Length(StrEax) do
                    begin
                        stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                        env.doFunction(trunc(EntEax.Num));
                        if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) = 0) 
                            then StrEbx := StrEbx + StrEax[index];
    		        end;
                end else begin
                    //StrEcx := 'sfilt_'+IntToStr(DateTimeToUnix(Now));
                    //for index := 1 to Length(StrEax) do
                    //begin
                    //    env.Variables.setLocalVariable(StrEcx, buildString(StrEax[index]));
                    //    env.Stack := parseOpen('$' + StrEcx + ' ' + EntEax.Str, env.Stack, env.Settings, env.Variables);
                    //    if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) = 0) 
                    //        then StrEbx := StrEbx + StrEax[index];
    		        //end;
                    for index := 1 to Length(StrEax) do
                    begin
                        stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                        env.doFunction(trunc(EntEax.Num));
                        if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) = 0) 
                            then StrEbx := StrEbx + StrEax[index];
    		        end;
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
            end else Found := False;
        end;
        'String.cut' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TEXP, TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                StrEbx := '';
                env.Variables.addLayer();
                if (EntEax.EntityType = TFUN) then
                begin
                    for index := 1 to Length(StrEax) do
                    begin
                        stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                        env.doFunction(trunc(EntEax.Num));
                        if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) <> 0) 
                            then StrEbx := StrEbx + StrEax[index];
    		        end;
                end else begin
                    //StrEcx := 'scutt_'+IntToStr(DateTimeToUnix(Now));
                    //for index := 1 to Length(StrEax) do
                    //begin
                    //    env.Variables.setLocalVariable(StrEcx, buildString(StrEax[index]));
                    //    env.Stack := parseOpen('$' + StrEcx + ' ' + EntEax.Str, env.Stack, env.Settings, env.Variables);
                    //    if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) <> 0) 
                    //        then StrEbx := StrEbx + StrEax[index];
    		        //end;
                    for index := 1 to Length(StrEax) do
                    begin
                        stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                        env.doFunction(trunc(EntEax.Num));
                        if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) <> 0) 
                            then StrEbx := StrEbx + StrEax[index];
    		        end;
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
            end else Found := False;
        end;
        'String.reduce' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TSTR) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                env.Variables.addLayer();
                for index := 1 to Length(StrEax) do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
            end else Found := False;
        end;
        'String.reduceFromFirst' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                EntEbx := buildString(StrEax[1]);
                env.Variables.addLayer();
                for index := 2 to Length(StrEax) do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
            end else Found := False;
        end;
        'String.reduceLeft' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TSTR) then
            begin
                EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                env.Variables.addLayer();
                for index := 1 to Length(StrEax) do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
            end else Found := False;
        end;
        'String.reduceLeftFromFirst' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                EntEbx := buildString(StrEax[1]);
                env.Variables.addLayer();
                for index := 2 to Length(StrEax) do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
            end else Found := False;
        end;
        'String.reduceRight' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TSTR) then
            begin
                EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                env.Variables.addLayer();
                for index := Length(StrEax) downto 1 do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
            end else Found := False;
        end;
        'String.reduceRightFromLast' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                EntEbx := buildString(StrEax[Length(StrEax)]);
                env.Variables.addLayer();
                for index := Length(StrEax)-1 downto 1 do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
            end else Found := False;
        end;
        'String.strreduce' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                env.Variables.addLayer();
                for index := 1 to Length(StrEax) do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
            end else Found := False;
        end;
        'String.strreduceFromFirst' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                StrEbx := StrEax[1];
                env.Variables.addLayer();
                for index := 2 to Length(StrEax) do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
            end else Found := False;
        end;
        'String.strreduceLeft' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                env.Variables.addLayer();
                for index := 1 to Length(StrEax) do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
            end else Found := False;
        end;
        'String.strreduceLeftFromFirst' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                StrEbx := StrEax[1];
                env.Variables.addLayer();
                for index := 2 to Length(StrEax) do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
            end else Found := False;
        end;
        'String.strreduceRight' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                env.Variables.addLayer();
                for index := Length(StrEax) downto 1 do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
            end else Found := False;
        end;
        'String.strreduceRightFromLast' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                StrEbx := StrEax[Length(StrEax)];
                env.Variables.addLayer();
                for index := Length(StrEax)-1 downto 1 do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
                    stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[index]));
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEbx));
            end else Found := False;
        end;
        'String.first' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TSTR) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[1])); 
            end else Found := False;
        end;
        'String.last' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TSTR) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax[Length(StrEax)])); 
            end else Found := False;
        end;

        // String.-
        'String.delete' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) and (stack_getback(env.Stack[env.Settings.StackPointer], 1).EntityType = TSTR) then
            begin
                // STR1 STR2 delete
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax - StrEbx));
            end else if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) and (stack_getback(env.Stack[env.Settings.StackPointer], 1).EntityType = TNUM) then
            begin
                // STR1 NUM1 delete
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax - trunc(ExtEax)));
            end else Found := False;
        end;
        // String.*
        'String.copies' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TNUM) and (stack_getback(env.Stack[env.Settings.StackPointer], 1).EntityType = TSTR) then
            begin
                // NUM1 STR1 copies
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax * trunc(ExtEax)));
            end else if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) and (stack_getback(env.Stack[env.Settings.StackPointer], 1).EntityType = TNUM) then
            begin
                // STR1 NUM1 copies
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax * trunc(ExtEax)));
            end else Found := False;
        end;
        // String./
        'String.divide' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) and (stack_getback(env.Stack[env.Settings.StackPointer], 1).EntityType = TSTR) then
            begin
                // STR1 STR2 delete
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax / StrEbx));
            end else if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TSTR) and (stack_getback(env.Stack[env.Settings.StackPointer], 1).EntityType = TNUM) then
            begin
                // STR1 NUM1 delete
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
                ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax / trunc(ExtEax)));
            end else Found := False;
        end;
        'String.removeMatching' : begin
            //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEax / StrEbx));
        end;
        // logics
        'String.isEmpty' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TSTR) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(StrEax = ''));
            end else Found := False;
        end;

        // others
        'String.translate' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEcx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (length(StrEbx) = length(StrEcx))
                then stack_push(env.Stack[env.Settings.StackPointer], buildString(StringTranslate(StrEax, StrEbx, StrEcx)))
                else stack_push(env.Stack[env.Settings.StackPointer], raiseStringSameLength(i));
        end;

        else begin
        	Found := false;
        end;
	end;
	Result := Found;
end;

function lib_directives(i : String; var env : PSEnvironment; var db : PSCommandDB) : Boolean;
var
	Found          : Boolean;
	StrEax         : String;
    IntEax, IntEbx : Integer;
begin
	Found := true;
    //writeln('dir: ', i);
    if (i[1] <> '@') then begin
        Found := false;
        lib_directives := false;
        Exit;
    end;
	case i of
        '@silent' : begin
           env.Settings.Prevent := true;
        end;
        '@silent(true)' : begin
           env.Settings.Prevent := true;
        end;
        '@silent(false)' : begin
           env.Settings.Prevent := false;
        end;
        '@silent(TRUE)' : begin
           env.Settings.Prevent := true;
        end;
        '@silent(FALSE)' : begin
           env.Settings.Prevent := false;
        end;
        '@autoclear(true)' : begin
           env.Settings.Autoclear := true;
        end;
        '@autoclear(false)' : begin
           env.Settings.Autoclear := false;
        end;
        '@autoclear(TRUE)' : begin
           env.Settings.Autoclear := true;
        end;
        '@autoclear(FALSE)' : begin
           env.Settings.Autoclear := false;
        end;
        '@stricttype(true)' : begin
           env.Settings.StrictType := true;
        end;
        '@stricttype(false)' : begin
           env.Settings.StrictType := false;
        end;
        '@stricttype(TRUE)' : begin
           env.Settings.StrictType := true;
        end;
        '@stricttype(FALSE)' : begin
           env.Settings.StrictType := false;
        end;
        '@casesensitive(true)' : begin
           env.Settings.CaseSensitive := true;
        end;
        '@casesensitive(false)' : begin
           env.Settings.CaseSensitive := false;
        end;
        '@casesensitive(TRUE)' : begin
           env.Settings.CaseSensitive := true;
        end;
        '@casesensitive(FALSE)' : begin
           env.Settings.CaseSensitive := false;
        end;
        '@infmode' : begin
           env.Settings.InfMode := true;
        end;
        '@infmode(TRUE)' : begin
           env.Settings.InfMode := true;
        end;
        '@infmode(FALSE)' : begin
           env.Settings.InfMode := false;
        end;
        '@infmode(true)' : begin
           env.Settings.InfMode := true;
        end;
        '@infmode(false)' : begin
           env.Settings.InfMode := false;
        end;
        '@real' : begin
           env.Settings.Mask := '0.################';
        end;
        '@decimal' : begin
           env.Settings.Mask := '#,###.################';
        end;
        '@milli' : begin
           env.Settings.Mask := '0.000';
        end;
        '@float' : begin
           env.Settings.Mask := '0.000000';
        end;
        '@double' : begin
           env.Settings.Mask := '0.000000000000000';
        end;
        '@money' : begin
           env.Settings.Mask := '0.00';
        end;
        '@amoney' : begin
           env.Settings.Mask := '#,###.00';
        end;
        '@int' : begin
           env.Settings.Mask := '0';
        end;
        '@scientific' : begin
           env.Settings.Mask := '0.################E+00';
        end;
        '@scientific1' : begin
           env.Settings.Mask := '0.000000000000000E+0000';
        end;
        '@sorttype(BUBBLESORT)' : begin
           env.Settings.sorttype := 0;
        end;
        '@sorttype(QUICKSORT)' : begin
           env.Settings.sorttype := 1;
        end;
        '@sorttype(MERGESORT)' : begin
           env.Settings.sorttype := 2;
        end;
        '@sorttype(BOGOSORT)' : begin
           env.Settings.sorttype := 3;
        end;
        '@sorttype(RANDOMSORT)' : begin
           env.Settings.sorttype := 3;
        end;
        '@sorttype(BSORT)' : begin
           env.Settings.sorttype := 0;
        end;
        '@sorttype(QSORT)' : begin
           env.Settings.sorttype := 1;
        end;
        '@sorttype(MSORT)' : begin
           env.Settings.sorttype := 2;
        end;
        '@sorttype(RSORT)' : begin
           env.Settings.sorttype := 3;
        end;
        '@sorttype(0)' : begin
           env.Settings.sorttype := 0;
        end;
        '@sorttype(1)' : begin
           env.Settings.sorttype := 1;
        end;
        '@sorttype(2)' : begin
           env.Settings.sorttype := 2;
        end;
        '@sorttype(3)' : begin
           env.Settings.sorttype := 3;
        end;
        '@useshell(BASH)' : begin
           env.Settings.Shell := SHELL_BASH;
        end;
        '@useshell(ZSH)' : begin
           env.Settings.Shell := SHELL_ZSH;
        end;
        '@useshell(SH)' : begin
           env.Settings.Shell := SHELL_SH;
        end;
        '@useshell(CMD)' : begin
           env.Settings.Shell := SHELL_CMD;
        end;
        '@useshell(POWERSHELL)' : begin
           env.Settings.Shell := SHELL_PWSH;
        end;
        '@useshell(PWSH)' : begin
           env.Settings.Shell := SHELL_PWSH;
        end;

		'@use(Math)' : begin
           env.Settings.Packages.UseMath := true;
		   env.Settings.Packages.UseAnything := true;
        end;
		'@unuse(Math)' : begin
           env.Settings.Packages.UseMath := false;
		   env.Settings.Packages.UseAnything := verifyPackages(env.Settings.Packages);
        end;
		'@use(String)' : begin
           env.Settings.Packages.UseString := true;
		   env.Settings.Packages.UseAnything := true;
        end;
		'@unuse(String)' : begin
           env.Settings.Packages.UseString := false;
		   env.Settings.Packages.UseAnything := verifyPackages(env.Settings.Packages);
        end;
        '@use(Array)' : begin
           env.Settings.Packages.UseArray := true;
		   env.Settings.Packages.UseAnything := true;
        end;
		'@unuse(Array)' : begin
           env.Settings.Packages.UseArray := false;
		   env.Settings.Packages.UseAnything := verifyPackages(env.Settings.Packages);
        end;
        '@use(Console)' : begin
           env.Settings.Packages.UseConsole := true;
		   env.Settings.Packages.UseAnything := true;
        end;
		'@unuse(Console)' : begin
           env.Settings.Packages.UseConsole := false;
		   env.Settings.Packages.UseAnything := verifyPackages(env.Settings.Packages);
        end;
        '@use(Date)' : begin
           env.Settings.Packages.UseDate := true;
		   env.Settings.Packages.UseAnything := true;
        end;
		'@unuse(Date)' : begin
           env.Settings.Packages.UseDate := false;
		   env.Settings.Packages.UseAnything := verifyPackages(env.Settings.Packages);
        end;
        '@use(Number)' : begin
           env.Settings.Packages.UseNumber := true;
		   env.Settings.Packages.UseAnything := true;
        end;
		'@unuse(Number)' : begin
           env.Settings.Packages.UseNumber := false;
		   env.Settings.Packages.UseAnything := verifyPackages(env.Settings.Packages);
        end;
        


        '@stringmode' : begin
            env.Settings.StringStart := 0;
            env.Settings.StringMode := MCLIKE;
        end;
        '@stringmode(DEFAULT)' : begin
            env.Settings.StringStart := 0;
            env.Settings.StringMode := MCLIKE;
        end;
        '@stringmode(CLIKE)' : begin
            env.Settings.StringStart := 0;
            env.Settings.StringMode := MCLIKE;
        end;
        '@stringmode(PASCAL)' : begin
            env.Settings.StringStart := 1;
            env.Settings.StringMode := MPASCL;
        end;

        '@stringindex' : begin
            env.Settings.StringStart := 0;
        end;
        '@stringindex(DEFAULT)' : begin
            env.Settings.StringStart := 0;
        end;
        '@stringindex(0)' : begin
            env.Settings.StringStart := 0;
        end;
        '@stringindex(1)' : begin
            env.Settings.StringStart := 1;
        end;

        '@maxprecision(0)' : begin
            env.Settings.Mask := '0';
        end;
        '@fixprecision(0)' : begin
            env.Settings.Mask := '0';
        end;
        '@maxprecision(-1)' : begin
            env.Settings.Mask := '0.################';
        end;
        '@fixprecision(-1)' : begin
            env.Settings.Mask := '0.000000000000000';
        end;
        '@maxprecision(DEFAULT)' : begin
            env.Settings.Mask := '0.################';
        end;
        '@fixprecision(DEFAULT)' : begin
            env.Settings.Mask := '0.000000000000000';
        end;
		
        else begin
        	case LeftStr(i, 9) of
            	'@source("' : begin
              		if (RightStr(i, 2) = '")') then begin
                		StrEax := RightStr(i, Length(i)-9);
                		StrEax := LeftStr(StrEax, Length(StrEax)-2);
                		read_sourcefile(StrEax, env, db);
              		end else begin
                        stack_push(env.Stack[env.Settings.StackPointer], raiseException('ESyntax:CExpression: Syntax Error at expression "'+i+'".'));
              		end;
             	end;
             	else begin
                    case LeftStr(i, 14) of
                        '@maxprecision(' : begin
                            if (RightStr(i, 1) = ')') then begin
                                StrEax := RightStr(i, Length(i)-14);
                		        StrEax := LeftStr(StrEax, Length(StrEax)-1);
                                if (TryStrToInt(StrEax, IntEax)) 
                                then begin
                                    if IntEax > 0 then
                                    begin
                                        StrEax := '0.';
                                        for IntEbx := 1 to IntEax do
                                            StrEax := StrEax + '#';
                                        env.Settings.Mask := StrEax;
                                    end else begin
                                        stack_push(env.Stack[env.Settings.StackPointer], raiseException('EConstraint:CIntegerEx: a non-negative integer (or -1) expected at "'+i+'".'));  
                                    end;
                                end else begin
                                    stack_push(env.Stack[env.Settings.StackPointer], raiseException('EConstraint:CIntegerEx: a non-negative integer (or -1) expected at "'+i+'".'));
                                end;
                            end else begin
                	        	stack_push(env.Stack[env.Settings.StackPointer], raiseException('ESyntax:CExpression: Syntax Error at expression "'+i+'".'));
              		        end;
                        end;
                        '@fixprecision(' : begin
                            if (RightStr(i, 1) = ')') then begin
                                StrEax := RightStr(i, Length(i)-14);
                		        StrEax := LeftStr(StrEax, Length(StrEax)-1);
                                if (TryStrToInt(StrEax, IntEax)) 
                                then begin
                                    if IntEax > 0 then
                                    begin
                                        StrEax := '0.';
                                        for IntEbx := 1 to IntEax do
                                            StrEax := StrEax + '0';
                                        env.Settings.Mask := StrEax;
                                    end else begin
                                        stack_push(env.Stack[env.Settings.StackPointer], raiseException('EConstraint:CIntegerEx: a non-negative integer (or -1) expected at "'+i+'".'));  
                                    end;
                                end else begin
                                    stack_push(env.Stack[env.Settings.StackPointer], raiseException('EConstraint:CIntegerEx: a non-negative integer (or -1) expected at "'+i+'".'));
                                end;
                            end else begin
                	        	stack_push(env.Stack[env.Settings.StackPointer], raiseException('ESyntax:CExpression: Syntax Error at expression "'+i+'".'));
              		        end;
                        end;
                        else Found := false;
                    end;
             	end;
        	end;
        end;
    end;
    lib_directives := Found;
end;

function lib_constants(i : String; var env : PSEnvironment; var db : PSCommandDB) : Boolean;
var
	Found  : Boolean;
begin
	Found := true;
	case i of
        'NULL' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNull());
        end;
        'TRUE' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(True));
        end;
        'FALSE' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(False));
        end;
        else begin
        	Found := false;
        end;
	end;
    lib_constants := Found;
end;


function lib_variables(i : String; var env : PSEnvironment; var db : PSCommandDB) : Boolean;
var
	Found  : Boolean;
	StrEax, StrEbx : String;
	EntEax : Entity;
	LogEax : Boolean;
begin
	Found := true;
    case LeftStr(i, 1) of
    	'$' : begin
      		if (RightStr(i, Length(i)-1) <> '') then begin
        		StrEax := RightStr(i, Length(i)-1);
                if LeftStr(StrEax, 7) = 'global.'  
                    then EntEax := env.Variables.getGlobalVariable(StrEax)
                    else EntEax := env.Variables.getVariable(StrEax);
    			stack_push(env.Stack[env.Settings.StackPointer], EntEax);
      		end else begin
                stack_push(env.Stack[env.Settings.StackPointer], raiseGetUnnamedVariable());
      		end;
     	end;
     	'>' : begin 
     		if (RightStr(i, Length(i)-1) <> '') then begin
        		StrEax := RightStr(i, Length(i)-1);
        		EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if isValidForVariables(StrEax) then
                begin
                    if LeftStr(StrEax, 7) = 'global.' 
                        then env.Variables.setGlobalVariable(StrEax, EntEax)
                        else
    			            //env.Variables.setVariable(StrEax, EntEax);
                            env.Variables.setLocalVariable(StrEax, EntEax);
                        
                end else begin
                    stack_push(env.Stack[env.Settings.StackPointer], raiseSetInvalidVariable(i, StrEax));
                end;
      		end else begin
        		stack_push(env.Stack[env.Settings.StackPointer], raiseSetUnnamedVariable());
      		end;
     	end;
     	'?' : begin 
     		if (RightStr(i, Length(i)-1) <> '') then begin
        		StrEax := RightStr(i, Length(i)-1);
    			LogEax := env.Variables.isVarAssigned(StrEax);
    			stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(LogEax));
      		end else begin
        		stack_push(env.Stack[env.Settings.StackPointer], raiseGetUnnamedVariable());
      		end;
     	end;
     	'~' : begin 
     		if (RightStr(i, Length(i)-1) <> '') then begin
        		StrEax := RightStr(i, Length(i)-1);
    			env.Variables.removeVariable(StrEax);
      		end else begin
        		stack_push(env.Stack[env.Settings.StackPointer], raiseGetUnnamedVariable());
      		end;
     	end;
     	else begin
            case LeftStr(i, 2) of
                //'@@' : begin 
                //    if (RightStr(i, Length(i)-2) <> '') then begin
                //        StrEax := RightStr(i, Length(i)-2);
                //        EntEax := env.Variables.getVariable(StrEax);
                //        if LeftStr(StrEax, 7) = 'global.' 
                //            then EntEax := env.Variables.getGlobalVariable(StrEax)
                //            else EntEax := env.Variables.getVariable(StrEax);
                //        if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], EntEax, TFUN, i)) then Exit;   
                //        doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                //    end else begin
                //        stack_push(env.Stack[env.Settings.StackPointer], raiseGetUnnamedVariable());
                //    end;
                //end;
                '->' : begin 
     		        if (RightStr(i, Length(i)-2) <> '') then begin
                		StrEax := RightStr(i, Length(i)-2);
                		EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
    	        		if isValidForVariables(StrEax) then
                        begin
                            if LeftStr(StrEax, 7) = 'global.' 
                                then env.Variables.setGlobalVariable(StrEax, EntEax) 
                                else
    			                    //env.Variables.setVariable(StrEax, EntEax);
                                    env.Variables.setLocalVariable(StrEax, EntEax);
                        end else begin
                            stack_push(env.Stack[env.Settings.StackPointer], raiseSetInvalidVariable(i, StrEax));
                        end;
      	        	end else begin
                		stack_push(env.Stack[env.Settings.StackPointer], raiseSetUnnamedVariable());
      	        	end;
     	        end;
                else begin
                    Found := false;
                end;
            end;
     	end;
    end;
    Result := Found;
end;

// to trash
function lib_logics(i : String; var env : PSEnvironment; var db : PSCommandDB) : Boolean;
var
	Found                  : Boolean;
	EntEax, EntEbx         : Entity;
	LogEax, LogEbx, LogEcx : Boolean;
begin
	Found := true;
	case i of
		'=' : begin
    		EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
    		EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
    		LogEax := (EntEax.Str = EntEbx.Str) and (EntEax.Num = EntEbx.Num);
    		stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(LogEax));
		end;
		'!=' : begin
    		EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
    		EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
    		LogEax := not ((EntEax.Str = EntEbx.Str) and (EntEax.Num = EntEbx.Num));
    		stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(LogEax));
		end;
		'>' : begin
    		EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
    		EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
    		LogEax := EntEax.Num > EntEbx.Num;
    		stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(LogEax));
		end;
		'<' : begin
    		EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
    		EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
    		LogEax := EntEax.Num < EntEbx.Num;
    		stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(LogEax));
		end;
		'<=' : begin
    		EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
    		EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
    		LogEax := EntEax.Num <= EntEbx.Num;
    		stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(LogEax));
		end;
		'>=' : begin
    		EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
    		EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
    		LogEax := EntEax.Num >= EntEbx.Num;
    		stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(LogEax));
		end;
		'and' : begin
    		EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
    		EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
    		if EntEax.Num = 0 then LogEax := true else LogEax := false;
    		if EntEbx.Num = 0 then LogEbx := true else LogEbx := false;
    		LogEcx := LogEax and LogEbx;
    		stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(LogEcx));
		end;
		'or' : begin
    		EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
    		EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
    		if EntEax.Num = 0 then LogEax := true else LogEax := false;
    		if EntEbx.Num = 0 then LogEbx := true else LogEbx := false;
    		LogEcx := LogEax or LogEbx;
    		stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(LogEcx));
		end;
		'xor' : begin
    		EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
    		EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
    		if EntEax.Num = 0 then LogEax := true else LogEax := false;
    		if EntEbx.Num = 0 then LogEbx := true else LogEbx := false;
    		LogEcx := LogEax xor LogEbx;
    		stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(LogEcx));
		end;
		'not' : begin
    		EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
    		if EntEax.Num = 0 then LogEax := true else LogEax := false;
    		LogEcx := not LogEax;
    		stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(LogEcx));
		end;
		else begin
        	Found := false;
       	end;
    end;
    lib_logics := Found;
end;

function lib_consolemanipulators(i : String; var env : PSEnvironment; var db : PSCommandDB) : Boolean;
var
    Found   : Boolean;
    x, y, z : ShortInt;
    StrEax  : String; 
    StrEbx  : String;
    StrEcx  : String;
    a       : Integer;
    index   : LongInt;
begin
    Found := true;
    case i of
        'Console.textColor' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            TextColor(y);
        end;
        'Console.textColour' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            TextColor(y);
        end;
        'Console.textBackground' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            TextBackground(y);
        end;
        {$IfNDef MSWINDOWS}
        'Console.textColorANSI' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            TextColorANSI(y);
        end;
        'Console.textColourANSI' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            TextColorANSI(y);
        end;
        'Console.textBackgroundANSI' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            TextBackgroundANSI(y); 
        end;
        'Console.textColorRGB' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            z := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            TextColorRGB(x, y, z);
        end;
        'Console.textColourRGB' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            z := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            TextColorRGB(x, y, z);
        end;
        'Console.textBackgroundRGB' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            z := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            TextBackgroundRGB(x, y, z);
        end;
        'Console.textReset' : begin
            TextReset();
        end;
        'Console.textBold' : begin
            TextBold();
        end;
        'Console.textItalic' : begin
            TextItalic();
        end;
        'Console.textUnderline' : begin
            TextUnderline();
        end;
        'Console.textBlink' : begin
            TextBlink();
        end;
        'Console.textFastBlink' : begin
            TextFastBlink();
        end;
        'Console.textInverse' : begin
            TextInverse();
        end;
        'Console.textBoldOff' : begin
            TextBoldOff();
        end;
        'Console.textItalicOff' : begin
            TextItalicOff();
        end;
        'Console.textUnderlineOff' : begin
            TextUnderlineOff();
        end;
        'Console.textBlinkOff' : begin
            TextBlinkOff();
        end;
        'Console.textFastBlinkOff' : begin
            TextFastBlinkOff();
        end;
        'Console.textInverseOff' : begin
            TextInverseOff();
        end;
        {$ENDIF}
        'Console.delay' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            a := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            Delay(a);
        end;
        {$IFDEF MSWINDOWS}
        'Console.whereX' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(WhereX()));
        end;
        'Console.whereY' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(WhereY()));
        end;
        'Console.startSound' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            a := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            Sound(a);
        end;
        'Console.stopSound' : begin
            NoSound();
        end;
        {$ENDIF}
        'Console.gotoXY' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            GotoXY(x,y);
        end;
        'Console.clrscr' : begin
            clrscr();
        end;
        'Console.clearScreen' : begin
            clrscr();
        end;
        'Console.runCommand' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            StrEcx := executeCommand(StrEbx, env.Settings.Shell);
            stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEcx));
        end;
        'Console.UserName' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildString(getUser()));
        end;
        'Console.UserHome' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildString(GetUserDir()));
        end;
        'Console.HostName' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildString(getHost()));
        end;
        'Console.OSName' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildString(getOS()));
        end;
        'Console.OSVersion' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildString(getOSVersion()));
        end;
        'Console.OSDistribution' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildString(getOSDistribution()));
        end;
        'Console.OSDist' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildString(getOSDistribution()));
        end;
         'Console.OSDistributionFull' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildString(getOSDistributionFull()));
        end;
        'Console.OSDistFull' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildString(getOSDistributionFull()));
        end;
        'Console.CPUArchitecture' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildString(getCPUArch()));
        end;
        'Console.CPUArch' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildString(getCPUArch()));
        end;
        'Console.CPUBits' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getCPUBits()));
        end;
        'Console.system' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            StrEcx := executeCommand(StrEbx, env.Settings.Shell);
            stack_push(env.Stack[env.Settings.StackPointer], buildString(StrEcx));
        end;
        'Console.CPUNames' : begin
            for index := 0 to getRealCPUThreads()-1 do
                stack_push(env.Stack[env.Settings.StackPointer], buildString(getCPUName(index)));
        end;
        'Console.CPUThreads' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getRealCPUThreads()));
        end;
        'Console.CPUBaseFreqs' : begin
            for index := 0 to getRealCPUThreads()-1 do
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getCPUBaseFreq(index)));
        end;
        {$IFDEF LINUX}
        'Console.UserShell' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildString(getShell()));
        end;
        'Console.CPUMaxFreqs' : begin
            for index := 0 to getRealCPUThreads()-1 do
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getCPUMaxFreq(index)));
        end;
        'Console.CPUMinFreqs' : begin
            for index := 0 to getRealCPUThreads()-1 do
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getCPUMinFreq(index)));
        end;
        'Console.CPUCurrentFreqs' : begin
            for index := 0 to getRealCPUThreads()-1 do
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getCPUCurFreq(index)));
        end;
        'Console.CPUUsages' : begin
            for index := 0 to getRealCPUThreads()-1 do
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getCPUUsage(index)));
        end;
        'Console.CPUAllUsage' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getCPUUsage()));
        end;
        'Console.CPUUptime' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getUptime()));
        end;
        'Console.RAMTotal' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getRAMTotal()));
        end;
        'Console.RAMUsage' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getRAMUsage()));
        end;
        'Console.RAMFree' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getRAMFree()));
        end;
        'Console.RAMAvailable' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getRAMAvailable()));
        end;
        'Console.SwapTotal' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getSwapTotal()));
        end;
        'Console.SwapUsage' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getSwapUsage()));
        end;
        'Console.SwapFree' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getSwapFree()));
        end;
        'Console.ScreenResolution' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildString(getScreenResolution()));
        end;
        'Console.ScreenWidth' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getScreenWidth()));
        end;
        'Console.ScreenHeight' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(getScreenHeight()));
        end;
        {$ENDIF}
        'Console.getShell' : begin
           stack_push(env.Stack[env.Settings.StackPointer], buildString(env.Settings.Shell));
        end;
        'Console.setShell' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            env.Settings.Shell := StrEbx;
        end;
        'Console.isUnix' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(isUnix()));
        end;
        'Console.isLinux' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(isLinux()));
        end;
        'Console.isWindows' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(isWindows()));
        end;
        else begin
            Found := false;
        end;
    end;
    lib_consolemanipulators := Found;
end;

function lib_exceptions(i : String; var env : PSEnvironment; var db : PSCommandDB) : Boolean;
var
    Found  : Boolean;
    ExcEax : Entity;
begin
    Found := true;
    case i of
        'EXC' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildException(''));
        end;
        'toException' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            stack_push(env.Stack[env.Settings.StackPointer], buildException(stack_pop(env.Stack[env.Settings.StackPointer]).Str));
        end;
        'raiseException' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TEXC) then
            begin
                ExcEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                ExcEax.Num := 1;
                stack_push(env.Stack[env.Settings.StackPointer], ExcEax);
            end else //if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TSTR) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], raiseException(stack_pop(env.Stack[env.Settings.StackPointer]).Str));    
            end;
        end;
        else begin
            Found := false;
        end;
    end;
    lib_exceptions := Found;
end;

function lib_arrays(i : String; var env : PSEnvironment; var db : PSCommandDB) : Boolean;
var
	Found                  : Boolean;
    IntEax, IntEbx, IntEcx : LongInt;
    ArrEax, ArrEbx, ArrEcx : Entity;
    EntEax, EntEbx         : Entity;
    LogEax                 : Boolean;
    StrEax                 : String;
    ExtEax                 : Extended;
    index                  : Integer;
begin
	Found := true;
	case i of
        'Array.crush' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_reverse(env.Stack[trunc(ArrEax.Num)]);
                for index := 0 to stack_size(env.Stack[trunc(ArrEax.Num)])-1 do
                begin
                    EntEax := stack_getFront(env.Stack[trunc(ArrEax.Num)], index);
                    stack_push(env.Stack[env.Settings.StackPointer], EntEax);
                end;
                //stack_reverse(env.Stack[trunc(ArrEax.Num)]);
            end else Found := False;
        end;
        'Array.destroy' : begin
            //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_reverse(env.Stack[trunc(ArrEax.Num)]);
            for index := 0 to stack_size(env.Stack[trunc(ArrEax.Num)])-1 do
            begin
                EntEax := stack_pop(env.Stack[trunc(ArrEax.Num)]);
                stack_push(env.Stack[env.Settings.StackPointer], EntEax);
            end;
        end;
        'Array.getAt' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[IntEax]);
            end else Found := False;
        end;
        'Array.getAt!' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                EntEax := stack_popFront(env.Stack[trunc(ArrEax.Num)], IntEax);
                stack_push(env.Stack[env.Settings.StackPointer], EntEax);
            end else Found := False;
        end;
        'Array.setAt' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TVEC) then
            begin
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                //
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, stack_size(env.Stack[trunc(ArrEax.Num)])));
                ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
                IntEbx := 0;
                while (IntEbx <= stack_size(env.Stack[trunc(ArrEax.Num)])-1) do
                begin
                    if (IntEax = IntEbx)
                        then env.Stack[trunc(ArrEcx.Num)].Values[IntEbx] := EntEax
                        else env.Stack[trunc(ArrEcx.Num)].Values[IntEbx] := env.Stack[trunc(ArrEax.Num)].Values[IntEbx];
                    IntEbx := IntEbx + 1;
                end;
                stack_push(env.Stack[env.Settings.StackPointer], ArrEcx);
            end else Found := False;
        end;
        'Array.setAt!' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TVEC) then
            begin
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                env.Stack[trunc(ArrEax.Num)].Values[IntEax] := EntEax;
                stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
            end else Found := False;
        end;
        'Array.setAt!!' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TVEC) then
            begin
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                env.Stack[trunc(ArrEax.Num)].Values[IntEax] := EntEax;
                //stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
            end else Found := False;
        end;
        'Array.push' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, stack_size(env.Stack[trunc(ArrEax.Num)])));
            ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
            IntEbx := 0;
            while (IntEbx <= stack_size(env.Stack[trunc(ArrEax.Num)])-1) do
            begin
                env.Stack[trunc(ArrEcx.Num)].Values[IntEbx] := env.Stack[trunc(ArrEax.Num)].Values[IntEbx];
                IntEbx := IntEbx + 1;
            end;
            stack_push(env.Stack[trunc(ArrEcx.Num)], EntEax);
            stack_push(env.Stack[env.Settings.StackPointer], ArrEcx);
        end;
        'Array.push!' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[trunc(ArrEax.Num)], EntEax);
            stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
        end;
        'Array.push!!' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[trunc(ArrEax.Num)], EntEax);
            //stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
        end;
        'Array.getTail' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            EntEax := stack_get(env.Stack[trunc(ArrEax.Num)]);
            stack_push(env.Stack[env.Settings.StackPointer], EntEax);
        end;
        'Array.getTail!' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            EntEax := stack_pop(env.Stack[trunc(ArrEax.Num)]);
            stack_push(env.Stack[env.Settings.StackPointer], EntEax);
        end;
        'Array.pop' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, stack_size(env.Stack[trunc(ArrEax.Num)])-1));
            ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
            IntEbx := 0;
            while (IntEbx <= stack_size(env.Stack[trunc(ArrEax.Num)])-2) do
            begin
                env.Stack[trunc(ArrEcx.Num)].Values[IntEbx] := env.Stack[trunc(ArrEax.Num)].Values[IntEbx];
                IntEbx := IntEbx + 1;
            end;
            //EntEax := stack_pop(env.Stack[trunc(ArrEcx.Num)]);
            stack_push(env.Stack[env.Settings.StackPointer], ArrEcx);
        end;
        'Array.pop!' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            EntEax := stack_pop(env.Stack[trunc(ArrEax.Num)]);
            stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
        end;
        'Array.pop!!' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            EntEax := stack_pop(env.Stack[trunc(ArrEax.Num)]);
            //stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
        end;
        'Array.getHead' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[0]);
        end;
        'Array.getHead!' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            EntEax := stack_firstpop(env.Stack[trunc(ArrEax.Num)]);
            stack_push(env.Stack[env.Settings.StackPointer], EntEax);
        end;

        'Array.shift' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, stack_size(env.Stack[trunc(ArrEax.Num)])-1));
            ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
            IntEbx := 0;
            while (IntEbx <= stack_size(env.Stack[trunc(ArrEax.Num)])-2) do
            begin
                env.Stack[trunc(ArrEcx.Num)].Values[IntEbx] := env.Stack[trunc(ArrEax.Num)].Values[IntEbx+1];
                IntEbx := IntEbx + 1;
            end;
            //EntEax := stack_pop(env.Stack[trunc(ArrEcx.Num)]);
            stack_push(env.Stack[env.Settings.StackPointer], ArrEcx);
        end;
        'Array.shift!' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            EntEax := stack_firstpop(env.Stack[trunc(ArrEax.Num)]);
            stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
        end;
        'Array.shift!!' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            EntEax := stack_firstpop(env.Stack[trunc(ArrEax.Num)]);
            //stack_push(env.Stack[env.Settings.StackPointer], EntEax);
        end;
        'Array.pushAt' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, stack_size(env.Stack[trunc(ArrEax.Num)])+1));
            ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
            IntEbx := 0;
            while (IntEbx < IntEax) do
            begin
                env.Stack[trunc(ArrEcx.Num)].Values[IntEbx] := env.Stack[trunc(ArrEax.Num)].Values[IntEbx];
                IntEbx := IntEbx + 1;
            end;
            env.Stack[trunc(ArrEcx.Num)].Values[IntEax] := EntEax;
            IntEbx := IntEbx + 1;
            while (IntEbx <= stack_size(env.Stack[trunc(ArrEax.Num)])) do
            begin
                env.Stack[trunc(ArrEcx.Num)].Values[IntEbx] := env.Stack[trunc(ArrEax.Num)].Values[IntEbx-1];
                IntEbx := IntEbx + 1;
            end;
            //stack_push(env.Stack[trunc(ArrEcx.Num)], EntEax);
            stack_push(env.Stack[env.Settings.StackPointer], ArrEcx);
        end;
        'Array.pushAt!' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_pushFront(env.Stack[trunc(ArrEax.Num)], EntEax, IntEax);
            stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
        end;
        'Array.pushAt!!' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_pushFront(env.Stack[trunc(ArrEax.Num)], EntEax, IntEax);
        end;
        'Array.popAt' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, stack_size(env.Stack[trunc(ArrEax.Num)])-1));
            ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
            IntEbx := 0;
            while (IntEbx < IntEax) do
            begin
                env.Stack[trunc(ArrEcx.Num)].Values[IntEbx] := env.Stack[trunc(ArrEax.Num)].Values[IntEbx];
                IntEbx := IntEbx + 1;
            end;
            //env.Stack[trunc(ArrEcx.Num)].Values[IntEax] := EntEax;
            IntEbx := IntEbx + 1;
            while (IntEbx <= stack_size(env.Stack[trunc(ArrEax.Num)])-1) do
            begin
                env.Stack[trunc(ArrEcx.Num)].Values[IntEbx-1] := env.Stack[trunc(ArrEax.Num)].Values[IntEbx];
                IntEbx := IntEbx + 1;
            end;
            //EntEax := stack_pop(env.Stack[trunc(ArrEcx.Num)]);
            stack_push(env.Stack[env.Settings.StackPointer], ArrEcx);
        end;
        'Array.popAt!' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            EntEax := stack_popFront(env.Stack[trunc(ArrEax.Num)], IntEax);
            stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
        end;
        'Array.popAt!!' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            EntEax := stack_popFront(env.Stack[trunc(ArrEax.Num)], IntEax);
            //stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
        end;
        
        'Array.length' : begin
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, TVEC, i)) then Exit; 
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                IntEax := trunc(stack_get(env.Stack[env.Settings.StackPointer]).Num);
                if (env.Settings.Autoclear) then stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(stack_size(env.Stack[IntEax])));
            end else Found := False;
        end;
        'Array.toJSString' : begin
          	EntEax := stack_get(env.Stack[env.Settings.StackPointer]);
            if (env.Settings.Autoclear) then stack_pop(env.Stack[env.Settings.StackPointer]);
            if (EntEax.EntityType = TVEC) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildString(stack_showArrayFull(env.Stack[trunc(EntEax.Num)], env.Stack, env.Settings.Mask))); 
            end else begin
                stack_push(env.Stack[env.Settings.StackPointer], buildString(EntEax.Str));
            end;
        end;
        'Array.reduceSum' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_sum(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.reduceProduct' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_product(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.reduceAvg' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_avg(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.reduceMean' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_avg(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.reduceMeanGeom' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_avg_geom(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.reduceMeanHarm' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_avg_power(env.Stack[trunc(ArrEax.Num)].Values, -1)));
        end;
        'Array.reduceMeanSq' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_avg2(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.reducePowerMean' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_avg_power(env.Stack[trunc(ArrEax.Num)].Values, ExtEax)));
        end;
        'Array.reduceVariance' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_variance(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.reduceStddev' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_stddev(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.reduceStdDev' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_stddev(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.reduceMedian' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_median(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.reduceMode' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], table_mode(env.Stack[trunc(ArrEax.Num)].Values));
        end;
        'Array.reduceModeStr' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], table_modeStr(env.Stack[trunc(ArrEax.Num)].Values));
        end;
        'Array.reduceGCD' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_gcd(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.reduceLCM' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_lcm(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.reduceMin' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_min(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.reduceMax' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_max(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.findMin' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_min2(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.findMax' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(table_max2(env.Stack[trunc(ArrEax.Num)].Values)));
        end;
        'Array.sortNumbers' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (env.Settings.sorttype = 0) then bubblesort(env.Stack[trunc(ArrEax.Num)].Values);
            if (env.Settings.sorttype = 1) then quicksort(env.Stack[trunc(ArrEax.Num)].Values);
            if (env.Settings.sorttype = 2) then mergesort(env.Stack[trunc(ArrEax.Num)].Values);
            if (env.Settings.sorttype = 3) then bogosort(env.Stack[trunc(ArrEax.Num)].Values);
            stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
        end;
        'Array.sortStrings' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            strings_sort(env.Stack[trunc(ArrEax.Num)].Values);
            stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
        end;
        'Array.belongs' : begin
            EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            LogEax := False;
            for EntEbx in env.Stack[trunc(ArrEax.Num)].Values do
            begin
                //if (EntEax.Str = EntEbx.Str) and (EntEax.Num = EntEbx.Num) then 
                if EntEax = EntEbx then 
                begin 
                    LogEax := True;
                    break;
                end;
    		end;
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(LogEax));
        end;
        'Array.map' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, Length(env.Stack[trunc(ArrEax.Num)].Values)));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                env.Variables.addLayer();
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[index]);
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    env.Stack[trunc(ArrEbx.Num)].Values[index] := stack_pop(env.Stack[env.Settings.StackPointer]);
    		    end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.reduce' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TVEC) then
            begin
                EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                env.Variables.addLayer();
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                    stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[index]);
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
    		    end;
                stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                env.Variables.removeLayer();
            end else Found := False;
        end;
        'Array.reduceLeft' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TVEC) then
            begin
                EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                env.Variables.addLayer();
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                    stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[index]);
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
    		    end;
                stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                env.Variables.removeLayer();
            end else Found := False;
        end;
        'Array.reduceFromFirst' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                env.Variables.addLayer();
                EntEbx := env.Stack[trunc(ArrEax.Num)].Values[0];
                for index := 1 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                    stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[index]);
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
    		    end;
                stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                env.Variables.removeLayer();
            end else Found := False;
        end;
        'Array.reduceLeftFromFirst' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                env.Variables.addLayer();
                EntEbx := env.Stack[trunc(ArrEax.Num)].Values[0];
                for index := 1 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                    stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[index]);
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
    		    end;
                stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                env.Variables.removeLayer();
            end else Found := False;
        end;
        'Array.reduceRight' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TVEC) then
            begin
                EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                env.Variables.addLayer();
                for index := Length(env.Stack[trunc(ArrEax.Num)].Values)-1 downto 0 do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                    stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[index]);
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
    		    end;
                stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                env.Variables.removeLayer();
            end else Found := False;
        end;
        'Array.reduceRightFromLast' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                env.Variables.addLayer();
                EntEbx := env.Stack[trunc(ArrEax.Num)].Values[Length(env.Stack[trunc(ArrEax.Num)].Values)-1];
                for index := Length(env.Stack[trunc(ArrEax.Num)].Values)-2 downto 0 do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                    stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[index]);
                    //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                    env.doFunction(trunc(EntEax.Num));
                    EntEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
    		    end;
                stack_push(env.Stack[env.Settings.StackPointer], EntEbx);
                env.Variables.removeLayer();
            end else Found := False;
        end;
        'Array.join' : begin
            if  (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) 
            and (stack_getback(env.Stack[env.Settings.StackPointer], 1).EntityType = TVEC) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                IntEax := Length(env.Stack[trunc(ArrEax.Num)].Values);
                IntEbx := Length(env.Stack[trunc(ArrEbx.Num)].Values);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, IntEax + IntEbx));
                ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to IntEax-1 do
                begin
                    env.Stack[trunc(ArrEcx.Num)].Values[index] := env.Stack[trunc(ArrEax.Num)].Values[index];
                end; 
                for index := 0 to IntEbx-1 do
                begin
                    env.Stack[trunc(ArrEcx.Num)].Values[IntEax+index] := env.Stack[trunc(ArrEbx.Num)].Values[index];
                end;
                stack_push(env.Stack[env.Settings.StackPointer], ArrEcx);
            end else Found := False;
        end;
        'Array.split' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
                IntEbx := Length(env.Stack[trunc(ArrEcx.Num)].Values) - IntEax;
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, IntEax));
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, IntEbx));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to IntEax-1 do
                begin
                    env.Stack[trunc(ArrEax.Num)].Values[index] := env.Stack[trunc(ArrEcx.Num)].Values[index];
                end; 
                for index := 0 to IntEbx-1 do
                begin
                    env.Stack[trunc(ArrEbx.Num)].Values[index] := env.Stack[trunc(ArrEcx.Num)].Values[IntEax+index];
                end;
                stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.filter' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TEXP, i)) then Exit;
                if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TEXP, TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                env.Variables.addLayer();
                if (EntEax.EntityType = TFUN) then
                begin
                    for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                    begin
                        stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[index]);
                        //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                        env.doFunction(trunc(EntEax.Num));
                        if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) = 0) then
                            stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		        end;
                end else begin
                    for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                    begin
                        stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[index]);
                        //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                        env.doFunction(trunc(EntEax.Num));
                        if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) <> 0) then
                            stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		        end;
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.cut' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TEXP, i)) then Exit;
                if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TEXP, TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                env.Variables.addLayer();
                if (EntEax.EntityType = TFUN) then
                begin
                    for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                    begin
                        stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[index]);
                        //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                        env.doFunction(trunc(EntEax.Num));
                        if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) <> 0) then
                            stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		        end;
                end else begin
                    //StrEax := 'acutt_'+IntToStr(DateTimeToUnix(Now));
                    //for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                    //begin
                    //    env.Variables.setLocalVariable(StrEax, env.Stack[trunc(ArrEax.Num)].Values[index]);
                    //    env.Stack := parseOpen('$' + StrEax + ' ' + EntEax.Str, env.Stack, env.Settings, env.Variables);
                    //    if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) <> 0) then
                    //        stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		        //end;
                    for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                    begin
                        stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[index]);
                        //doFunctionOld(EntEax, env.Stack, env.Settings, env.Variables);
                        env.doFunction(trunc(EntEax.Num));
                        if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) <> 0) then
                            stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		        end;
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.splitByExpression' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TEXP, TFUN, i)) then Exit;
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
                env.Variables.addLayer();
                if (EntEax.EntityType = TFUN) then
                begin
                    for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                    begin
                        stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[index]);
                        env.doFunction(trunc(EntEax.Num));
                        if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) = 0) 
                            then stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index])
                            else stack_push(env.Stack[trunc(ArrEcx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		        end;
                end else begin
                    for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                    begin
                        stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[index]);
                        env.doFunction(trunc(EntEax.Num));
                        if (trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num) = 0) 
                            then stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index])
                            else stack_push(env.Stack[trunc(ArrEcx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		        end;
                end;
                env.Variables.removeLayer();
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                stack_push(env.Stack[env.Settings.StackPointer], ArrEcx);
            end else Found := False;
        end;
        'Array.unweave' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
            ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
            ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
            env.Variables.addLayer();
            for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
            begin
                if (index mod 2 = 0) 
                    then stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index])
                    else stack_push(env.Stack[trunc(ArrEcx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		end;
            env.Variables.removeLayer();
            stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            stack_push(env.Stack[env.Settings.StackPointer], ArrEcx);
        end;
        'Array.weave' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            IntEax := Length(env.Stack[trunc(ArrEax.Num)].Values);
            IntEbx := Length(env.Stack[trunc(ArrEbx.Num)].Values);
            stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, IntEax + IntEbx));
            ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
            IntEcx := 0;
            if (IntEax <= IntEbx) then
            begin
                for index := 0 to IntEax-1 do
                begin
                    env.Stack[trunc(ArrEcx.Num)].Values[IntEcx] := env.Stack[trunc(ArrEax.Num)].Values[index];
                    env.Stack[trunc(ArrEcx.Num)].Values[IntEcx+1] := env.Stack[trunc(ArrEbx.Num)].Values[index];
                    Inc(IntEcx, 2);
                end;
                for index := IntEax to IntEbx-1 do
                begin
                    env.Stack[trunc(ArrEcx.Num)].Values[IntEcx] := env.Stack[trunc(ArrEbx.Num)].Values[index];
                    Inc(IntEcx, 1);
                end;
            end else begin
                for index := 0 to IntEbx-1 do
                begin
                    env.Stack[trunc(ArrEcx.Num)].Values[IntEcx] := env.Stack[trunc(ArrEax.Num)].Values[index];
                    env.Stack[trunc(ArrEcx.Num)].Values[IntEcx+1] := env.Stack[trunc(ArrEbx.Num)].Values[index];
                    Inc(IntEcx, 2);
                end;
                for index := IntEbx to IntEax-1 do
                begin
                    env.Stack[trunc(ArrEcx.Num)].Values[IntEcx] := env.Stack[trunc(ArrEax.Num)].Values[index];
                    Inc(IntEcx, 1);
                end;
            end; 
            stack_push(env.Stack[env.Settings.StackPointer], ArrEcx);
        end;
        'Array.left' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, IntEax));
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to IntEax-1 do
                begin
                    env.Stack[trunc(ArrEax.Num)].Values[index] := env.Stack[trunc(ArrEcx.Num)].Values[index];
                end; 
                stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
            end else Found := False;
        end;
        'Array.right' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, IntEax));
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to IntEax-1 do
                begin
                    env.Stack[trunc(ArrEax.Num)].Values[index] := env.Stack[trunc(ArrEcx.Num)].Values[Length(env.Stack[trunc(ArrEcx.Num)].Values)-IntEax+index];
                end; 
                stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
            end else Found := False;
        end;
        'Array.cutLeft' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, Length(env.Stack[trunc(ArrEcx.Num)].Values)-IntEax));
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEcx.Num)].Values)-IntEax-1 do
                begin
                    env.Stack[trunc(ArrEax.Num)].Values[index] := env.Stack[trunc(ArrEcx.Num)].Values[index+IntEax];
                end; 
                stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
            end else Found := False;
        end;
        'Array.cutRight' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, Length(env.Stack[trunc(ArrEcx.Num)].Values)-IntEax));
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEcx.Num)].Values)-IntEax-1 do
                begin
                    env.Stack[trunc(ArrEax.Num)].Values[index] := env.Stack[trunc(ArrEcx.Num)].Values[index];
                end; 
                stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
            end else Found := False;
        end;
        'Array.between' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEbx := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, IntEbx-IntEax+1));
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to IntEbx-IntEax do
                begin
                    env.Stack[trunc(ArrEax.Num)].Values[index] := env.Stack[trunc(ArrEcx.Num)].Values[IntEax+index];
                end; 
                stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
            end else Found := False;
        end;
        'Array.subarray' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            IntEbx := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, IntEbx));
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            for index := 0 to IntEbx-1 do
            begin
                env.Stack[trunc(ArrEax.Num)].Values[index] := env.Stack[trunc(ArrEcx.Num)].Values[IntEax+index];
            end; 
            stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
        end;
        'Array.cutBothSides' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEbx := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, Length(env.Stack[trunc(ArrEcx.Num)].Values)-IntEax-IntEbx));
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEcx.Num)].Values)-IntEax-IntEbx-1 do
                begin
                    env.Stack[trunc(ArrEax.Num)].Values[index] := env.Stack[trunc(ArrEcx.Num)].Values[IntEax+index];
                end; 
                stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
            end else Found := False;
        end;
        'Array.crushBy' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
          	    if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
                IntEcx := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_reverse(env.Stack[trunc(ArrEax.Num)]);

                IntEax := 0;
                while (IntEax <= stack_size(env.Stack[trunc(ArrEax.Num)])-1) do
                begin
                    stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                    ArrEcx := stack_pop(env.Stack[env.Settings.StackPointer]);
                    IntEbx := 0;
                    while (IntEbx < trunc(IntEcx)) and (IntEax <= stack_size(env.Stack[trunc(ArrEax.Num)])-1) do
                    begin
                        stack_push(env.Stack[trunc(ArrEcx.Num)], stack_getFront(env.Stack[trunc(ArrEax.Num)], IntEax));
                        IntEbx := IntEbx + 1;
                        IntEax := IntEax + 1;  
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEcx);
                end;
                stack_reverse(env.Stack[trunc(ArrEax.Num)]);

            end else Found := false;
        end;
        'Array.first' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[0]);
            end else Found := false;
        end;
        'Array.last' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], env.Stack[trunc(ArrEax.Num)].Values[Length(env.Stack[trunc(ArrEax.Num)].Values)-1]);
            end else Found := false;
        end;
        // crush, pushAt, popAt, swapAt, toString, size

         // logics
        'Array.isEmpty' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(stack_size(env.Stack[trunc(ArrEax.Num)]) = 0));
            end else Found := False;
        end;

        // 052 functions
        'Array.cutNulls' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    if not (isNull(env.Stack[trunc(ArrEax.Num)].Values[index])) then
                        stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
         'Array.cutZeros' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    if not (isZero(env.Stack[trunc(ArrEax.Num)].Values[index])) then
                        stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.cutEmptyStrings' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    if not (isEmptyString(env.Stack[trunc(ArrEax.Num)].Values[index])) then
                        stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.randomFrom' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
            ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
            stack_push(env.Stack[env.Settings.StackPointer], array_randomFrom(env.Stack[trunc(ArrEax.Num)].Values));
        end;
        'Array.distinct' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    if not (itemHappenedBefore(env.Stack[trunc(ArrEax.Num)].Values, index)) then
                        stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.distinctNumbers' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    if not (stringHappenedBefore(env.Stack[trunc(ArrEax.Num)].Values, index)) then
                        stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.distinctStrings' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    if not (stringHappenedBefore(env.Stack[trunc(ArrEax.Num)].Values, index)) then
                        stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.sort' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TVEC, i)) then Exit; 
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Stack[trunc(ArrEax.Num)].Values[index].EntityType = TSTR) then
                begin
                    strings_sort(env.Stack[trunc(ArrEax.Num)].Values);
                end else begin
                    case env.Settings.sorttype of
                        0 : bubblesort(env.Stack[trunc(ArrEax.Num)].Values);
                        1 : quicksort(env.Stack[trunc(ArrEax.Num)].Values);
                        2 : mergesort(env.Stack[trunc(ArrEax.Num)].Values);
                        3 : bogosort(env.Stack[trunc(ArrEax.Num)].Values);
                    end; 
                end;
                stack_push(env.Stack[env.Settings.StackPointer], ArrEax);
            end else Found := False;
        end;
        'Array.pad' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        if (IntEbx mod 2 = 0) 
                            then stack_pushFront(env.Stack[trunc(ArrEbx.Num)], buildNull())
                            else stack_push(env.Stack[trunc(ArrEbx.Num)], buildNull());
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padLeft' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        stack_pushFront(env.Stack[trunc(ArrEbx.Num)], buildNull());
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padRight' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        stack_push(env.Stack[trunc(ArrEbx.Num)], buildNull());
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padSpaces' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        if (IntEbx mod 2 = 0) 
                            then stack_pushFront(env.Stack[trunc(ArrEbx.Num)], buildString(' '))
                            else stack_push(env.Stack[trunc(ArrEbx.Num)], buildString(' '));
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padSpacesLeft' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        stack_pushFront(env.Stack[trunc(ArrEbx.Num)], buildString(' '));
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padSpacesRight' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        stack_push(env.Stack[trunc(ArrEbx.Num)], buildString(' '));
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padZeros' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        if (IntEbx mod 2 = 0) 
                            then stack_pushFront(env.Stack[trunc(ArrEbx.Num)], buildNumber(0.0))
                            else stack_push(env.Stack[trunc(ArrEbx.Num)], buildNumber(0.0));
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padZerosLeft' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        stack_pushFront(env.Stack[trunc(ArrEbx.Num)], buildNumber(0.0));
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padZerosRight' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        stack_push(env.Stack[trunc(ArrEbx.Num)], buildNumber(0.0));
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padNulls' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        if (IntEbx mod 2 = 0) 
                            then stack_pushFront(env.Stack[trunc(ArrEbx.Num)], buildNull())
                            else stack_push(env.Stack[trunc(ArrEbx.Num)], buildNull());
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padNullsLeft' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        stack_pushFront(env.Stack[trunc(ArrEbx.Num)], buildNull());
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padNullsRight' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        stack_push(env.Stack[trunc(ArrEbx.Num)], buildNull());
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padEmptyStrings' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        if (IntEbx mod 2 = 0) 
                            then stack_pushFront(env.Stack[trunc(ArrEbx.Num)], buildString(''))
                            else stack_push(env.Stack[trunc(ArrEbx.Num)], buildString(''));
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padEmptyStringsLeft' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        stack_pushFront(env.Stack[trunc(ArrEbx.Num)], buildString(''));
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padEmptyStringsRight' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        stack_push(env.Stack[trunc(ArrEbx.Num)], buildString(''));
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padEntities' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TVEC) then
            begin
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        if (IntEbx mod 2 = 0) 
                            then stack_pushFront(env.Stack[trunc(ArrEbx.Num)], EntEax)
                            else stack_push(env.Stack[trunc(ArrEbx.Num)], EntEax);
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padEntitiesLeft' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TVEC) then
            begin
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        stack_pushFront(env.Stack[trunc(ArrEbx.Num)], EntEax);
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.padEntitiesRight' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 3).EntityType = TVEC) then
            begin
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
                IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                if IntEax < Length(env.Stack[trunc(ArrEax.Num)].Values) then begin
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end else begin
                    IntEbx := 0;
                    while IntEbx < (IntEax - Length(env.Stack[trunc(ArrEax.Num)].Values)) do
                    begin
                        stack_push(env.Stack[trunc(ArrEbx.Num)], EntEax);
                        IntEbx := IntEbx + 1;
                    end;
                    stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
                end;
            end else Found := False;
        end;
        'Array.trim' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                index := 0;
                while isNull(stack_get(env.Stack[trunc(ArrEbx.Num)])) do stack_pop(env.Stack[trunc(ArrEbx.Num)]);
                while isNull(stack_getFront(env.Stack[trunc(ArrEbx.Num)])) do stack_popFront(env.Stack[trunc(ArrEbx.Num)]);
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.trimLeft' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                index := 0;
                //while isNull(stack_get(env.Stack[trunc(ArrEbx.Num)])) do stack_pop(env.Stack[trunc(ArrEbx.Num)]);
                while isNull(stack_getFront(env.Stack[trunc(ArrEbx.Num)])) do stack_popFront(env.Stack[trunc(ArrEbx.Num)]);
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.trimRight' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                index := 0;
                while isNull(stack_get(env.Stack[trunc(ArrEbx.Num)])) do stack_pop(env.Stack[trunc(ArrEbx.Num)]);
                //while isNull(stack_getFront(env.Stack[trunc(ArrEbx.Num)])) do stack_popFront(env.Stack[trunc(ArrEbx.Num)]);
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.trimNulls' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                index := 0;
                while isNull(stack_get(env.Stack[trunc(ArrEbx.Num)])) do stack_pop(env.Stack[trunc(ArrEbx.Num)]);
                while isNull(stack_getFront(env.Stack[trunc(ArrEbx.Num)])) do stack_popFront(env.Stack[trunc(ArrEbx.Num)]);
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.trimNullsLeft' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                index := 0;
                //while isNull(stack_get(env.Stack[trunc(ArrEbx.Num)])) do stack_pop(env.Stack[trunc(ArrEbx.Num)]);
                while isNull(stack_getFront(env.Stack[trunc(ArrEbx.Num)])) do stack_popFront(env.Stack[trunc(ArrEbx.Num)]);
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.trimNullsRight' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TVEC) then
            begin
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                index := 0;
                while isNull(stack_get(env.Stack[trunc(ArrEbx.Num)])) do stack_pop(env.Stack[trunc(ArrEbx.Num)]);
                //while isNull(stack_getFront(env.Stack[trunc(ArrEbx.Num)])) do stack_popFront(env.Stack[trunc(ArrEbx.Num)]);
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.trimEntities' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                index := 0;
                while EntEax = stack_get(env.Stack[trunc(ArrEbx.Num)]) do stack_pop(env.Stack[trunc(ArrEbx.Num)]);
                while EntEax = stack_getFront(env.Stack[trunc(ArrEbx.Num)]) do stack_popFront(env.Stack[trunc(ArrEbx.Num)]);
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.trimEntitiesLeft' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                index := 0;
                //while EntEax = stack_get(env.Stack[trunc(ArrEbx.Num)])) do stack_pop(env.Stack[trunc(ArrEbx.Num)]);
                while EntEax = stack_getFront(env.Stack[trunc(ArrEbx.Num)]) do stack_popFront(env.Stack[trunc(ArrEbx.Num)]);
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        'Array.trimEntitiesRight' : begin
            if (stack_getback(env.Stack[env.Settings.StackPointer], 2).EntityType = TVEC) then
            begin
                EntEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                ArrEax := stack_pop(env.Stack[env.Settings.StackPointer]);
                stack_push(env.Stack[env.Settings.StackPointer], buildNewEmptyArray(env.Stack, env.Settings, 0));
                ArrEbx := stack_pop(env.Stack[env.Settings.StackPointer]);
                for index := 0 to Length(env.Stack[trunc(ArrEax.Num)].Values)-1 do
                begin
                    stack_push(env.Stack[trunc(ArrEbx.Num)], env.Stack[trunc(ArrEax.Num)].Values[index]);
    		    end;
                index := 0;
                while EntEax = stack_get(env.Stack[trunc(ArrEbx.Num)]) do stack_pop(env.Stack[trunc(ArrEbx.Num)]);
                //while EntEax = stack_getFront(env.Stack[trunc(ArrEbx.Num)])) do stack_popFront(env.Stack[trunc(ArrEbx.Num)]);
                stack_push(env.Stack[env.Settings.StackPointer], ArrEbx);
            end else Found := False;
        end;
        else begin
            Found := false;
        end;
	end;
	lib_arrays := Found;
end;

function lib_files(i : String; var env : PSEnvironment; var db : PSCommandDB) : Boolean;
var
	Found  : Boolean;
    StrEax : String; 
begin
	Found := true;
	case i of
        'runFile' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit; 
            StrEax := stack_get(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.Autoclear) then stack_pop(env.Stack[env.Settings.StackPointer]);
        	read_sourcefile(StrEax, env, db);
        end;    
        else begin
            Found := false;
        end;
	end;
	lib_files := Found;
end;

function lib_datetime(i : String; var env : PSEnvironment; var db : PSCommandDB) : Boolean;
var
	Found                  : Boolean;
    StrEax                 : String; 
    IntEax                 : LongInt;
    ExtEax, ExtEbx, ExtEcx : Extended;
    DatEax, DatEbx, DatEcx : TDateTime;
begin
	Found := true;
	case i of
        'Date.toDateTime' : begin
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TNUM) then
            begin
                ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
        	    //stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(TimestampToDateTime(ExtEax)));
                stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(ExtEax));
            end else begin
                StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
                stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(StringYMDToDateTime(StrEax)));
                //stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(VarToDateTime(StrEax)));
            end;
        end; 
        'Date.YMDtoDateTime' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(StringYMDToDateTime(StrEax)));
        end; 
        'Date.MDYtoDateTime' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(StringMDYToDateTime(StrEax)));
        end; 
        'Date.DMYtoDateTime' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(StringDMYToDateTime(StrEax)));
        end; 
        'Date.toTimestamp' : begin
            //if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TNUM) or (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TDAT) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(stack_pop(env.Stack[env.Settings.StackPointer]).Num));
            end else if (stack_get(env.Stack[env.Settings.StackPointer]).EntityType = TSTR) then
            begin
                stack_push(env.Stack[env.Settings.StackPointer], buildNumber(DateTimeToUnix(StringYMDToDateTime(stack_pop(env.Stack[env.Settings.StackPointer]).Str))));
            end;
        end; 
        'Date.now' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(Now));
        end; 
        'Date.today' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(Today));
        end; 
        'Date.yesterday' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(Yesterday));
        end; 
        'Date.tomorrow' : begin
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(Tomorrow));
        end; 
        'Date.unixEpoch' : begin
            ExtEax := 0;
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(ExtEax));
        end; 
        'Date.truncDate' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            //StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            //DatEax := StringYMDToDateTime(StrEax));
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(DateOf(DatEax)));
        end;
        'Date.truncTime' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(TimeOf(DatEax)));
        end;
        'Date.getYear' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(YearOf(DatEax)));
        end;
        'Date.getMonth' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(MonthOf(DatEax)));
        end;
        'Date.getDay' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(DayOf(DatEax)));
        end;
        'Date.getHour' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(HourOf(DatEax)));
        end;
        'Date.getHour24' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(HourOf(DatEax)));
        end;
        'Date.getHour12' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(((HourOf(DatEax))-1) mod 12 + 1));
        end;
        'Date.getMinute' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(MinuteOf(DatEax)));
        end;
        'Date.getSecond' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(SecondOf(DatEax)));
        end;
        'Date.getMillisecond' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(MillisecondOf(DatEax)));
        end;
        'Date.getWeekDay' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(DayOfTheWeek(DatEax)));
        end;
        'Date.getYearDay' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(DayOfTheYear(DatEax)));
        end;
        'Date.isPM' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(IsPM(DatEax)));
        end;
        'Date.isLeapYear' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(IsLeapYear(IntEax)));
        end;
        'Date.isInLeapYear' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(IsInLeapYear(DatEax)));
        end;
        'Date.setYear' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(RecodeYear(DatEax, IntEax)));
        end;
        'Date.setMonth' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(RecodeMonth(DatEax, IntEax)));
        end;
        'Date.setDay' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(RecodeDay(DatEax, IntEax)));
        end;
        'Date.setHour' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(RecodeHour(DatEax, IntEax)));
        end;
        'Date.setMinute' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(RecodeMinute(DatEax, IntEax)));
        end;
        'Date.setSecond' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(RecodeSecond(DatEax, IntEax)));
        end;
        'Date.setMillisecond' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(RecodeMillisecond(DatEax, IntEax)));
        end;
        'Date.addYear' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(IncYear(DatEax, IntEax)));
        end;
        'Date.addMonth' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(IncMonth(DatEax, IntEax)));
        end;
        'Date.addDay' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(IncDay(DatEax, IntEax)));
        end;
        'Date.addHour' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(IncHour(DatEax, IntEax)));
        end;
        'Date.addMinute' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(IncMinute(DatEax, IntEax)));
        end;
        'Date.addSecond' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(IncSecond(DatEax, IntEax)));
        end;
        'Date.addWeek' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(IncDay(DatEax, IntEax*7)));
        end;
        'Date.addMillisecond' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;  
            IntEax := trunc(stack_pop(env.Stack[env.Settings.StackPointer]).Num);
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildDateTime(IncMillisecond(DatEax, IntEax)));
        end;
        'Date.diffYear' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(YearsBetween(DatEax, DatEbx)));
        end;
        'Date.diffMonth' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(MonthsBetween(DatEax, DatEbx)));
        end;
        'Date.diffDay' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(DaysBetween(DatEax, DatEbx)));
        end;
        'Date.diffHour' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(HoursBetween(DatEax, DatEbx)));
        end;
        'Date.diffMinute' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(MinutesBetween(DatEax, DatEbx)));
        end;
        'Date.diffSecond' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(SecondsBetween(DatEax, DatEbx)));
        end;
        'Date.diffMillisecond' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(MillisecondsBetween(DatEax, DatEbx)));
        end;
        'Date.spanYear' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(YearSpan(DatEax, DatEbx)));
        end;
        'Date.spanMonth' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(MonthSpan(DatEax, DatEbx)));
        end;
        'Date.spanDay' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(DaySpan(DatEax, DatEbx)));
        end;
        'Date.spanHour' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(HourSpan(DatEax, DatEbx)));
        end;
        'Date.spanMinute' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(MinuteSpan(DatEax, DatEbx)));
        end;
        'Date.spanSecond' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(SecondSpan(DatEax, DatEbx)));
        end;
        'Date.spanMillisecond' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(MillisecondSpan(DatEax, DatEbx)));
        end;
        'Date.diffWeek' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(WeeksBetween(DatEax, DatEbx)));
        end;
        'Date.spanWeek' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(WeekSpan(DatEax, DatEbx)));
        end;
        'Date.compare' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(CompareDateTime(DatEbx, DatEax)));
        end;
        'Date.compareDate' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(CompareDate(DatEbx, DatEax)));
        end;
        'Date.compareTime' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(CompareTime(DatEbx, DatEax)));
        end;
        'Date.isInRange' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEcx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            DatEcx := TimestampToDateTime(ExtEcx);
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(DateTimeInRange(DatEax, DatEbx, DatEcx)));
        end;
        'Date.isDateInRange' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEcx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            DatEcx := TimestampToDateTime(ExtEcx);
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(DateInRange(DatEax, DatEbx, DatEcx)));
        end;
        'Date.isTimeInRange' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEcx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEbx := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit; 
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            DatEbx := TimestampToDateTime(ExtEbx);
            DatEcx := TimestampToDateTime(ExtEcx);
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(TimeInRange(DatEax, DatEbx, DatEcx)));
        end;
        'Date.getYearWeek' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(WeekOfTheYear(DatEax)));
        end;
        'Date.getMonthWeek' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(WeekOfTheMonth(DatEax)));
        end;
        'Date.format' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, i)) then Exit;
            //if (env.Settings.StrictType) and (assertEitherLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TDAT, TSTR, i)) then Exit;  
            ExtEax := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            DatEax := TimestampToDateTime(ExtEax);
            stack_push(env.Stack[env.Settings.StackPointer], buildString(FormatDateTime(StrEax, DatEax)));
        end;
        else begin
            Found := false;
        end;
	end;
	Result := Found;
end;

function lib_numbers(i : String; var env : PSEnvironment; var db : PSCommandDB) : Boolean;
var
	Found    : Boolean;
    x, y, z  : Extended;
    StrEax   : String;
begin
	Found := true;
	case i of
        'Number.inv' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := 1/y;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.abs' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := abs(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;

        // powers
        'Number.sqr' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := y*y;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.cub' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := y*y*y;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;

        // roots and logarithms
        'Number.log' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := ln(x)/ln(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
		'Number.lbin' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := log2(x);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.ldec' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := log10(x);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.lhex' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := ln(x)/ln(16);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.cbrt' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if y = 0 then begin
                z := 0;
            end else if y < 0 then begin
                z := -exp(ln(-y)/3);
            end else begin
                z := exp(ln(y)/3);
            end;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.sign' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (y = 0)
                then z := 0
                else z := y/abs(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.sgn' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (y = 0)
                then z := 0
                else z := y/abs(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.factorial' : begin
          	if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := fact(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.log2' : begin
          	if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := log2(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.log10' : begin
          	if (env.Settings.StrictType) and (assertNotNegativeLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := log10(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.log16' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := ln(x)/ln(16);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;

        // approximations
        'Number.floor' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := ffloor(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.ceiling' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := fceiling(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.round' : begin
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := fround(y);
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.truncTo' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := ftruncTo(y, trunc(x));
            
            
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.floorTo' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := ffloorTo(y, trunc(x));
            
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.ceilingTo' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := fceilingTo(y, trunc(x));
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;
        'Number.roundTo' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
          	if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            z := froundTo(y, trunc(x));
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(z));
        end;

        // boolean functions for numbers
        'Number.isPrime' : begin
            if (env.Settings.StrictType) and (assertNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(isPrime(y)));
        end;
		'Number.isEven' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            //stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(trunc(y) mod 2 = 0));
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(fmod(y, 2) = 0));
        end;
		'Number.isOdd' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit; 
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            //stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(trunc(y) mod 2 = 1));
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(fmod(y, 2) = 1));
        end;
		'Number.isInteger' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean(isInteger(y)));
        end;
        'Number.isNatural' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildBoolean((isInteger(y)) and (y >= 0)));
        end;

        'Number.decToBase' : begin
            if (env.Settings.StrictType) and (assertPositiveNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(convertDecToBase(trunc(x), trunc(y))));
        end;
        'Number.baseToDec' : begin
            if (env.Settings.StrictType) and (assertPositiveNaturalLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(convertBaseToDec(StrEax, trunc(y))));
        end;
        'Number.decToBin' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(convertDecToBase(trunc(x), 2)));
        end;
        'Number.binToDec' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(convertBaseToDec(StrEax, 2)));
        end;
        'Number.decToOct' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(convertDecToBase(trunc(x), 8)));
        end;
        'Number.octToDec' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(convertBaseToDec(StrEax, 8)));
        end;
        'Number.decToHex' : begin
            if (env.Settings.StrictType) and (assertIntegerLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), i)) then Exit;
            x := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(convertDecToBase(trunc(x), 16)));
        end;
        'Number.hexToDec' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TSTR, i)) then Exit;  
            StrEax := stack_pop(env.Stack[env.Settings.StackPointer]).Str;
            stack_push(env.Stack[env.Settings.StackPointer], buildNumber(convertBaseToDec(StrEax, 16)));
        end;

        'Number.toUSNumber' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(toNumberString(y, '.')));
        end;
        'Number.toUSNumber2' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(toNumberString(y, '.', ' ')));
        end;
        'Number.toUSNumber3' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(toNumberString(y, '.', ',')));
        end;
        'Number.toEUNumber' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(toNumberString(y, ',')));
        end;
        'Number.toEUNumber2' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(toNumberString(y, ',', ' ')));
        end;
        'Number.toEUNumber3' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(toNumberString(y, ',', '.')));
        end;
        'Number.toEUNumber4' : begin
            if (env.Settings.StrictType) and (assertEntityLocated(env.Stack[env.Settings.StackPointer], stack_get(env.Stack[env.Settings.StackPointer]), TNUM, i)) then Exit;
            y := stack_pop(env.Stack[env.Settings.StackPointer]).Num;
            stack_push(env.Stack[env.Settings.StackPointer], buildString(toNumberString(y, ',', '''')));
        end;
        
        
        //Number.toUSNumber2 (,)
        //Number.toUSNumber ( )
        //Number.toEUNumber ()
        //Number.toEUNumber2 (.)
        //Number.toEUNumber ( )
        
        //Number.toUSNumber ()
        //Number.toUSNumber2 (,)
        //Number.toUSNumber ( )
        //Number.toEUNumber ()
        //Number.toEUNumber2 (.)
        //Number.toEUNumber ( )
        //FormatFloat(Settings.Mask, EntEax.Num)
        else begin
            Found := false;
        end;
	end;
	Result := Found;
end;