

// old 
function checkLevelChar(input : Char) : Integer;
begin
         if (input = '{') then Result := 1
    else if (input = '[') then Result := 1
    else if (input = '(') then Result := 1
	else if (input = '}') then Result := -1
    else if (input = ']') then Result := -1
    else if (input = ')') then Result := -1
    else Result := 0;
    //writeln(input, ': ', Result);
end;

// new
function checkLevelCharInc(input : Char) : Integer;
begin
         if (input = '{') then Result := 1
    else if (input = '[') then Result := 1
    else if (input = '(') then Result := 1
    else Result := 0;
    //writeln(input, ': ', Result);
end;

function checkLevelCharDec(input : Char) : Integer;
begin
	     if (input = '}') then Result := 1
    else if (input = ']') then Result := 1
    else if (input = ')') then Result := 1
    else Result := 0;
end;

function splitToWords(input : String) : TStringArray;
var
    L      : TStringArray;
    i      : LongInt = 0;
    j      : LongInt = 1;
    cursor : LongInt = 1;
    quoted : Boolean = False;
    level  : LongInt = 0;
    str    : String;
begin
    if (Length(input) = 0) then
    begin
        SetLength(L, 0);
        Result := L;
    end else begin
        writeln('string to split: ', input);
        SetLength(L, 1);
        SetLength(L[0], 0);
        // first ones
        if (input[cursor] = '"') then quoted := not quoted;
        if not quoted then 
        begin
            if checkLevelCharInc(input[cursor]) = 1 then
            begin
                level := level + 1;
                i := i + 1;
                SetLength(L, i);
                SetLength(L[i], 0);
            end;
            L[i] := '' + input[cursor];
            if checkLevelCharDec(input[cursor]) = 1 then
            begin
                level := level - 1;
                i := i + 1;
                SetLength(L, i);
                SetLength(L[i], 0);
            end;
        end else begin
            L[i] := '' + input[cursor];
        end;
        writeln(L[i][1]);
        writeln('next step');
        // next ones
        for cursor := 2 to Length(input) do
        begin
            if (level <= 0) then
            begin
                if (input[cursor] = '"') and (input[cursor-1] <> '\') then quoted := not quoted;
                if not quoted then 
                begin
                    if checkLevelCharInc(input[cursor]) = 1 then
                    begin
                        L[i] := trim(L[i]);
                        level := level + 1;
                        i := i + 1;
                        SetLength(L, i+1);
                        SetLength(L[i], 0);
                    end;
                    L[i] := L[i] + input[cursor];
                    if checkLevelCharDec(input[cursor]) = 1 then
                    begin
                        L[i] := trim(L[i]);
                        level := level - 1;
                        i := i + 1;
                        SetLength(L, i+1);
                        SetLength(L[i], 0);
                    end;
                end else begin
                    L[i] := L[i] + input[cursor];
                end;
                writeln(i, #9, level, #9, L[i]);
            end else begin
                if (input[cursor] = '"') and (input[cursor-1] <> '\') then quoted := not quoted;
                if not quoted then 
                begin
                    if checkLevelCharInc(input[cursor]) = 1 then
                    begin
                        level := level + 1;
                        //i := i + 1;
                    end;
                    L[i] := L[i] + input[cursor];
                    if checkLevelCharDec(input[cursor]) = 1 then
                    begin
                        level := level - 1;
                        if (level = 0) then
                        begin
                            L[i] := trim(L[i]);
                            i := i+1;
                            SetLength(L, i+1);
                            SetLength(L[i], 0);
                        end;
                        //i := i + 1;
                    end;
                end else begin
                    L[i] := L[i] + input[cursor];
                end;
                writeln(i, #9, level, #9, L[i]);
            end;
        end;
        L[i] := trim(L[i]);
    end;
    writeln('done split');
    Result := L;
end;

//function makeWords(L : TStringArray) : TStringArray;
//begin
//
//end;

// old

procedure checkWordString(var str : String; var quoted : Boolean; var nesttx : String; var nestlv : LongInt);
var
    index  : LongInt;
begin
    if (Length(str) > 0) then 
    begin
        if (str[1] = '"') then quoted := not quoted;
        if not quoted then nestlv := nestlv + checkLevelChar(str[1]);
        nesttx := nesttx + str[1];
        for index := 2 to Length(str) do
        begin
            if (str[index] = '"') and (str[index-1] <> '\') then 
            begin
                //writeln('quote'); 
                quoted := not quoted;
            end;
            if not quoted then nestlv := nestlv + checkLevelChar(str[index]);
            nesttx := nesttx + str[index];
        end;
    end;
end;

function getScopedString(var L : TStringArray; var cursor : Integer; initStr : String = '') : String;
var
    nestlv : LongInt;
    nesttx : String;
    quoted : Boolean = False;
begin
    nestlv := 1;
    //writeln(initstr, Length(L[cursor]):8, nestlv:8, quoted:8);
    checkWordString(initstr, quoted, nesttx, nestlv);
    nesttx := initstr + ' ';
    Inc(cursor);
    while (nestlv > 0) and (cursor < Length(L)) do begin
        //writeln(L[cursor]:16, Length(L[cursor]):8, nestlv:8, quoted:8);
        checkWordString(L[cursor], quoted, nesttx, nestlv);
        nesttx := nesttx + ' ';
        Inc(cursor);
    end;
    //writeln(nesttx);
    if (Length(nesttx) > 0) then 
    begin
        nesttx := LeftStr(nesttx, Length(nesttx)-1);
        if (RightStr(nesttx, 1)[1] in ['}', ')', ']']) then nesttx := LeftStr(nesttx, Length(nesttx)-1); 
    end;
    Dec(cursor);
    Result := trimLeft(nesttx);
end;

function getQuotedString(var L : TStringArray; var cursor : Integer) : String;
var
    nesttx : String;
begin
    nesttx := L[cursor];
	Inc(cursor);
	repeat
		nesttx := nesttx + ' ' + L[cursor];
        //writeln(L[cursor], ' ', cursor);
        Inc(cursor);
	until ((RightStr(L[cursor-1], 1) = '"') and (RightStr(L[cursor-1], 2) <> '\"')) or (cursor-1 >= Length(L));
    Dec(cursor);
    //writeln(nesttx);
    if (RightStr(nesttx, 1) = '"')
        then Result := nesttx
        else raiserror('ESyntax:CQuotes: Wrong amount of quotation marks. Quotes are not closed.');
end;

//------------------------------------------------------
// code reader
// code evaluation engine

function getScopedCommands(var L : TStringArray; var cursor : Integer; initStr : String = ''; nestlv : LongInt = 1) : TStringArray;
var
    M      : TStringArray;
    index  : LongInt = 0;
    nesttx : String;
    quoted : Boolean = False;
begin
    SetLength(M, 1);
    if (initStr <> '') then
    begin
        //writeln('simpli', #9, cursor, #9, 0, #9, index, #9, initstr, #9, nestlv);
        checkWordString(initstr, quoted, nesttx, nestlv);
        SetLength(M, 1);
        M[0] := initstr;
    end;
    Inc(index);
    Inc(cursor);
    //while (nestlv > 0) and (cursor < Length(L)) and (L[cursor] <> '') do begin
    while L[cursor] = '' do Inc(cursor);
    while (nestlv > 0) and (cursor < Length(L)) do begin
        while L[cursor] = '' do Inc(cursor);
        //writeln('simpl', #9, cursor, #9, 0, #9, index, #9, L[cursor], #9, nestlv);
        checkWordString(L[cursor], quoted, nesttx, nestlv);
        SetLength(M, index+1);
        M[index] := L[cursor];
        Inc(index);
        Inc(cursor);
        while L[cursor] = '' do Inc(cursor);
        //writeln('next', #9, L[cursor]);
    end;
    //writeln(nesttx);
    if (RightStr(M[index-1], 1)[1] in ['}', ')', ']']) then M[index-1] := LeftStr(M[index-1], Length(M[index-1])-1); 
    Dec(cursor);
    //writeln('simple list');
    //write('0: ');
    //for index := 0 to Length(M)-1 do
    //    write('+', M[index], #9);
    //    //write(M[index], #9);
    //writeln();
    Result := M;
end;

function getScopedDelimitedCommands(var L : TStringArray; var cursor : Integer; initStr : String = '') : TStringArrArray;
var
    M      : TStringArrArray;
    index  : LongInt = 0;
    jndex  : LongInt = 0;
    nestlv : LongInt;
    nesttx : String;
    quoted : Boolean = False;
begin
    nestlv := 1;
    //SetLength(M, 0);
    SetLength(M, 1);
    //writeln('delimi', #9, cursor, #9, jndex, #9, index, #9, initstr);
    if (initStr <> '') then
    begin
        checkWordString(initstr, quoted, nesttx, nestlv);
        //SetLength(M, 1);
        SetLength(M[jndex], 1);
        M[jndex][0] := initstr;
        Inc(index);
    end;
    Inc(cursor);
    while (nestlv > 0) and (cursor < Length(L)) do begin
        while L[cursor] = '' do Inc(cursor);
        checkWordString(L[cursor], quoted, nesttx, nestlv);
        if (nestlv = 1) and (L[cursor][1] in [':', ';']) and (not quoted) then
        begin
            Inc(jndex, 1);
            index := 0;
            Inc(cursor);
            SetLength(M, jndex+1);
            SetLength(M[jndex], index+1);
            //writeln('delimn', #9, cursor, #9, jndex, #9, index, #9, L[cursor]);
            checkWordString(L[cursor], quoted, nesttx, nestlv);
            M[jndex][index] := L[cursor];
            Inc(index);
            Inc(cursor);
        end else begin
            SetLength(M[jndex], index+1);
            M[jndex][index] := L[cursor];
            Inc(index);
            Inc(cursor);
        end;
    end;
    //writeln(nesttx);
    for index := 0 to jndex do
    begin
        nestlv := Length(M[index])-1;
        if (RightStr(M[index][nestlv], 1)[1] in ['}', ')', ']']) 
            then M[index][nestlv] := LeftStr(M[index][nestlv], Length(M[index][nestlv])-1); 
    end;

    //writeln('delimited list');
    //for index := 0 to Length(M)-1 do
    //begin
    //    write(index, ': ');
    //    for jndex := 0 to Length(M[index])-1 do
    //        write(M[index][jndex], #9);
    //    writeln();
    //end;
    Dec(cursor);
    Result := M;
end;

// repair to detect arrays
function getScopedCommand(var cursor : Integer; initStr : String = '') : TStringArray;
var
    M      : TStringArray;
    quoted : Boolean = False;
begin
    SetLength(M, 1);
    if (initStr <> '') then
    begin
        //checkWordString(initstr, quoted, nesttx, nestlv);
        SetLength(M, 1);
        M[0] := initstr;
    end;
    //if (RightStr(M[0], 1)[1] in ['}', ')', ']']) then M[0] := LeftStr(M[0], Length(M[0])-1); 
    Result := M;
end;

function PSEnvironment.makeListOfCommands(L : TStringArray; Args : TStringArray = Default(TStringArray)) : PSCommandDB;
var
    db     : PSCommandDB;
	index  : LongInt;
    x, y   : LongInt;
    z, z1  : LongInt;
    z2, z3 : LongInt;
    s1, s2 : String;
    StrEax : String;
    Num    : Extended;
    Code   : Longint;
    M              : TStringArrArray;
    N              : TStringArray = NIL;
    mode           : PSReaderMode = M_NORM;
    ConditionBuilt : Boolean = False;
begin
    x := Length(db.Commands);
    y := 0;
    SetLength(db.Commands, Length(db.Commands)+1);
    if Length(Args) > 0 then
    begin
        writeln('args ', #9, Length(Args));
        if (Length(Args[0]) > 0) and (Args[0][1] = '(') then Args[0] := RightStr(Args[0], Length(Args[0])-1); 
        for index := Length(Args)-1 downto 0 do
        begin
            if (Args[index] = '') then continue;
            if (Args[index][1] = '$') then Args[index] := RightStr(Args[index], Length(Args[index])-1);
            if isValidForVariables(Args[index]) then
            begin
                SetLength(db.Commands[x], y+1);
                db.Commands[x][y] := buildSetLocalVar(Args[index]);  
            end else begin
                raiserror('EVariable:CSetInvalid: Invalid variable string at "'+Args[index]+'"');
            end; 
            y := y+1;
        end;
    end;
    index := 0;
    writeln('length ', #9, x, #9, Length(L));
	while (index < Length(L)) do
	begin
        //writeln(index);
        //writeln(x);
        //writeln(L[index]);
        //writeln('ok');
        if (L[index] = '') then
		begin
            writeln('pass');
			Inc(index);
			continue;
		end;
        writeln('read ', #9, index, #9, x, #9, y, #9, L[index]);

        SetLength(db.Commands[x], y+1);
        case L[index] of
            '->' : begin
                index := index + 1;
                while (L[index] = '') do index := index + 1; 
                if (L[index][1] = '$') then L[index] := RightStr(L[index], Length(L[index])-1);
                if isValidForVariables(L[index]) then
                begin
                    if LeftStr(L[index], 7) = 'global.' then 
                    begin
                        db.Commands[x][y] := buildSetGlobalVar(L[index]);
                    end else begin
                        db.Commands[x][y] := buildSetLocalVar(L[index]);
                    end;     
                end else begin
                    raiserror('EVariable:CSetInvalid: Invalid variable string at "'+L[index]+'"');
                end;
            end;
            '+'   : db.Commands[x][y] := buildCalcAdd();
            '-'   : db.Commands[x][y] := buildCalcSub();
            '++'  : db.Commands[x][y] := buildCalcInc();
            '--'  : db.Commands[x][y] := buildCalcDec();
            '*'   : db.Commands[x][y] := buildCalcMul();
            '/'   : db.Commands[x][y] := buildCalcDiv();
            '='   : db.Commands[x][y] := buildTestEq();
		    '!='  : db.Commands[x][y] := buildTestNeq();
		    '>'   : db.Commands[x][y] := buildTestGt();
		    '<'   : db.Commands[x][y] := buildTestLt();
		    '<='  : db.Commands[x][y] := buildTestLe();
		    '>='  : db.Commands[x][y] := buildTestGe();
		    'and' : db.Commands[x][y] := buildTestAnd();
		    'or'  : db.Commands[x][y] := buildTestOr();
		    'xor' : db.Commands[x][y] := buildTestXor();
		    'not' : db.Commands[x][y] := buildTestNot();
            'inc' : db.Commands[x][y] := buildCalcInc();
            'dec' : db.Commands[x][y] := buildCalcDec();
            'rem'     : db.Commands[x][y] := buildCmdPop();
            'clone'   : db.Commands[x][y] := buildCmdClone();
            'qshift'  : db.Commands[x][y] := buildCmdQShift();
            'print'   : db.Commands[x][y] := buildCmdPrint();
            'println' : db.Commands[x][y] := buildCmdPrintLn();
            'scan'    : db.Commands[x][y] := buildCmdScan();
            'size'    : db.Commands[x][y] := buildCmdSize();
            'all'     : db.Commands[x][y] := buildCmdSize();
            'call'    : db.Commands[x][y] := buildCallFunction();
            else begin
                if ((LeftStr(L[index], 1) = '"') and (RightStr(L[index], 1) <> '"'))
                    or ((LeftStr(L[index], 1) = '"') and (RightStr(L[index], 2) = '\"'))
                    or (L[index] = '"') then begin
                    StrEax := getQuotedString(L, index);
                    StrEax := StrEax.Substring(1, StrEax.Length - 2);
                    if Settings.stringmode = MCLIKE then StrEax := string_fromC(StrEax);
                    db.Commands[x][y] := buildCmdPush(buildString(StrEax));
                end else if ((LeftStr(L[index], 1) = '"') and (RightStr(L[index], 1) = '"')) then begin
                    StrEax := L[index];
                    StrEax := StrEax.Substring(1, StrEax.Length - 2);
                    if Settings.stringmode = MCLIKE then StrEax := string_fromC(StrEax);
                    db.Commands[x][y] := buildCmdPush(buildString(StrEax));
                end else if LeftStr(L[index], 1) = '{' then begin
                    z := Length(db.Commands);
                    db := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                    db.Commands[x][y] := buildCmdJump(z);
                end else if LeftStr(L[index], 1) = '[' then begin
                    z := Length(db.Commands);
                    db := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                    db.Commands[x][y] := buildCreateArray(z);
                end else if LeftStr(L[index], 1) = '$' then begin
                    L[index] := RightStr(L[index], Length(L[index])-1);
                    if (L[index] <> '') then
                    begin
                        if isValidForVariables(L[index]) then
                        begin
                            if LeftStr(L[index], 7) = 'global.' then 
                            begin
                                db.Commands[x][y] := buildGetGlobalVar(L[index]);
                            end else begin
                                db.Commands[x][y] := buildGetLocalVar(L[index]);
                            end;     
                        end else begin
                            raiserror('EVariable:CGetInvalid: Invalid variable string at $'+L[index]+'');
                        end;
                    end else begin
                        db.Commands[x][y] := buildCmdPush(raiseGetUnnamedVariable());
                    end;
                end else if LeftStr(L[index], 1) = '>' then begin
                    L[index] := RightStr(L[index], Length(L[index])-1);
                    if (L[index] <> '') then
                    begin
                        if isValidForVariables(L[index]) then
                        begin
                            if LeftStr(L[index], 7) = 'global.' then 
                            begin
                                db.Commands[x][y] := buildSetGlobalVar(L[index]);
                            end else begin
                                db.Commands[x][y] := buildSetLocalVar(L[index]);
                            end;     
                        end else begin
                            raiserror('EVariable:CSetInvalid: Invalid variable string at >'+L[index]+'');
                        end;
                    end else begin
                        db.Commands[x][y] := buildCmdPush(raiseGetUnnamedVariable());
                    end;
                end else if LeftStr(L[index], 2) = '->' then begin
                    L[index] := RightStr(L[index], Length(L[index])-2);
                    if (L[index] <> '') then
                    begin
                        if (L[index][1] = '$') then L[index] := RightStr(L[index], Length(L[index])-1);
                        if isValidForVariables(L[index]) then
                        begin
                            if LeftStr(L[index], 7) = 'global.' then 
                            begin
                                db.Commands[x][y] := buildSetGlobalVar(L[index]);
                            end else begin
                                db.Commands[x][y] := buildSetLocalVar(L[index]);
                            end;     
                        end else begin
                            raiserror('EVariable:CSetInvalid: Invalid variable string at >'+L[index]+'');
                        end;
                    end else begin
                        db.Commands[x][y] := buildCmdPush(raiseGetUnnamedVariable());
                    end;
                end else if LeftStr(L[index], 2) = '@@' then begin
                    L[index] := RightStr(L[index], Length(L[index])-2);
                    if (L[index] <> '') then
                    begin
                        if isValidForVariables(L[index]) then
                        begin
                            if LeftStr(L[index], 7) = 'global.' then 
                            begin
                                db.Commands[x][y] := buildGetGlobalVar(L[index]);
                            end else begin
                                db.Commands[x][y] := buildGetLocalVar(L[index]);
                            end;  
                            y := y+1;
                            SetLength(db.Commands[x], y+1);   
                            db.Commands[x][y] := buildCallFunction(L[index]);
                        end else begin
                            raiserror('EVariable:CGetInvalid: Invalid variable string at $'+L[index]+'');
                        end;
                    end else begin
                        db.Commands[x][y] := buildCmdPush(raiseGetUnnamedVariable());
                    end;
                end else if checkWord(L[index], 'times', 5) then begin
                    L[index] := RightStr(L[index], Length(L[index])-5);
                    while (L[index] = '') do index := index + 1; 
                    z := Length(db.Commands);
                    if (LeftStr(L[index], 1) = '{') and (RightStr(L[index], 1) <> '}') then
                    begin
                        db := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                    end else begin
                        db := makeListOfCommands(getScopedCommands(L, index, L[index], 0));
                    end;
                    //makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)), db);
                    db.Commands[x][y] := buildDoTimes(z);
                end else if checkWord(L[index], 'while', 5) then begin
                    L[index] := RightStr(L[index], Length(L[index])-5);
                    while (L[index] = '') do index := index + 1; 
                    z := Length(db.Commands);
                    if (LeftStr(L[index], 1) = '(') and (RightStr(L[index], 1) <> ')') then
                    begin
                        db := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                    end else begin
                        db := makeListOfCommands(getScopedCommands(L, index, L[index], 0));
                    end;
                    index := index + 1;
                    while (L[index] = '') do index := index + 1; 
                    z1 := Length(db.Commands);
                    if (LeftStr(L[index], 1) = '{') and (RightStr(L[index], 1) <> '}') then
                    begin
                        db := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                    end else begin
                        db := makeListOfCommands(getScopedCommands(L, index, L[index], 0));
                    end;
                    db.Commands[x][y] := buildDoWhile(z, z1);
                end else if checkWord(L[index], 'do', 2) then begin
                    L[index] := RightStr(L[index], Length(L[index])-2);
                    while (L[index] = '') do index := index + 1; 
                    z1 := Length(db.Commands);
                    if (LeftStr(L[index], 1) = '{') and (RightStr(L[index], 1) <> '}') then
                    begin
                        db := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                    end else begin
                        db := makeListOfCommands(getScopedCommands(L, index, L[index], 0));
                    end;
                    index := index + 1;
                    while (L[index] = '') do index := index + 1; 
                    if checkWord(L[index], 'while', 5) then 
                    begin
                        L[index] := RightStr(L[index], Length(L[index])-5);
                        while (L[index] = '') do index := index + 1; 
                        z := Length(db.Commands);
                        if (LeftStr(L[index], 1) = '(') and (RightStr(L[index], 1) <> ')') then
                        begin
                            db := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                        end else begin
                            db := makeListOfCommands(getScopedCommands(L, index, L[index], 0));
                        end;
                        db.Commands[x][y] := buildDoDoWhile(z, z1);
                    end else if checkWord(L[index], 'until', 5) then
                    begin
                        L[index] := RightStr(L[index], Length(L[index])-5);
                        while (L[index] = '') do index := index + 1; 
                        z := Length(db.Commands);
                        if (LeftStr(L[index], 1) = '(') and (RightStr(L[index], 1) <> ')') then
                        begin
                            db := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                        end else begin
                            db := makeListOfCommands(getScopedCommands(L, index, L[index], 0));
                        end;
                        db.Commands[x][y] := buildDoDoUntil(z, z1);
                    end else begin
                        raiserror('ESyntax:CDoLoop: Invalid syntax of a DO-WHILE/DO-UNTIL loop');
                    end;
                end else if checkWord(L[index], 'for', 3) then begin
                    L[index] := RightStr(L[index], Length(L[index])-3);
                    while (L[index] = '') do index := index + 1; 
                    if (LeftStr(L[index], 1) = '(') and (RightStr(L[index], 1) <> ')') then
                    begin
                        //M := getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1));
                        M := getScopedDelimitedCommands(L, index, RightStr(L[index], Length(L[index])-1));
                    end else begin
                        raiserror('ESyntax:CFor: Invalid syntax of a FOR loop');
                        //M := getScopedCommand(index, L[index]);
                    end;
                    case Length(M) of
                        3 : begin
                            z1 := Length(db.Commands);
                            db := makeListOfCommands(M[0]);
                            z2 := Length(db.Commands);
                            db := makeListOfCommands(M[1]);
                            z3 := Length(db.Commands);
                            db := makeListOfCommands(M[2]);
                            index := index + 1;
                            while (L[index] = '') do index := index + 1; 
                            z := Length(db.Commands);
                            if (LeftStr(L[index], 1) = '{') and (RightStr(L[index], 1) <> '}') then
                            begin
                                db := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                            end else begin
                                db := makeListOfCommands(getScopedCommands(L, index, L[index], 0));
                            end;
                            db.Commands[x][y] := buildDoFor1(z1, z2, z3, z);
                        end;
                        2 : begin
                            // to fix
                            z2 := Length(M[0])-1;
                            if (z2 <= 2) then
                            begin
                                //writeln(z2);
                                if (z2 < 0) then raiserror('ESyntax:CForEach: No parameters in the FOR-EACH loop'); 
                                //writeln('ok');
                                if (z2 >= 0) then s2 := M[0][z2]       else s2 := ''; 
                                //writeln('ok');
                                if (z2 >= 1) then s1 := M[0][z2-1]     else s1 := ''; 
                                //writeln('ok');
                                if (z2  = 2) then StrEax := M[0][z2-2] else StrEax := ''; 
                                //writeln('ok');
                                if (StrEax <> '') and (StrEax <> 'const') then raiserror('ESyntax:CForEach: Invalid amount of parameters in the FOR-EACH loop'); 
                                if (Length(s1) > 0) and (s1[1] = '$') then s1 := RightStr(s1, Length(s1)-1);
                                if (s2[1] = '$') then s2 := RightStr(s2, Length(s2)-1);
                                if (Length(s1) > 0) and (not isValidForVariables(s1)) then
                                begin
                                    raiserror('EVariable:CSetInvalid: Invalid name of variable at "'+s1+'"');
                                end;
                                if (not isValidForVariables(s2)) then
                                begin
                                    raiserror('EVariable:CSetInvalid: Invalid name of variable at "'+s2+'"');
                                end;
                            end else begin
                                raiserror('ESyntax:CForEach: Invalid amount of parameters in the FOR-EACH loop');
                            end;
                            z1 := Length(db.Commands);
                            db := makeListOfCommands(M[1]);
                            index := index + 1;
                            while (L[index] = '') do index := index + 1; 
                            z := Length(db.Commands);
                            if (LeftStr(L[index], 1) = '{') and (RightStr(L[index], 1) <> '}') then
                            begin
                                db := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                            end else begin
                                //makeListOfCommands(getScopedCommand(index, L[index]), db);
                                db := makeListOfCommands(getScopedCommands(L, index, L[index], 0));
                            end;
                            db.Commands[x][y] := buildDoFor2(StrEax, s1, s2, z1, z);
                        end;
                        else begin
                            raiserror('ESyntax:CFor: Invalid syntax of a FOR loop');
                        end;
                    end;
                    for z := 0 to Length(M)-1 do SetLength(M[z], 0);
                    SetLength(M, 0);
                end else if checkWord(L[index], 'if', 2) then begin
                    L[index] := RightStr(L[index], Length(L[index])-2);
                    while (L[index] = '') do index := index + 1; 
                    ConditionBuilt := False;
                    z := Length(db.Conditionals);
                    SetLength(db.Conditionals, z+1);
                    z2 := Length(db.Commands);
                    if (LeftStr(L[index], 1) = '(') and (RightStr(L[index], 1) <> ')') then
                    begin
                        db := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                    end else begin
                        db := makeListOfCommands(getScopedCommands(L, index, L[index], 0));
                    end;
                    index := index + 1;
                    while (L[index] = '') do index := index + 1; 
                    z3 := Length(db.Commands);
                    if (LeftStr(L[index], 1) = '{') and (RightStr(L[index], 1) <> '}') then
                    begin
                        db := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                    end else begin
                        db := makeListOfCommands(getScopedCommands(L, index, L[index], 0));
                    end;
                    db.Conditionals[z].MainItem.Condition := z2;
                    db.Conditionals[z].MainItem.Instruction := z3;
                    db.Conditionals[z].ElseItem := -1;
                    z1 := Length(db.Conditionals[z].ElifItems);
                    //repeat
                    while (not ConditionBuilt) and (index < Length(L)) do
                    begin
                        index := index + 1;
                        while (L[index] = '') do index := index + 1; 
                        if checkWord(L[index], 'elif', 4) then
                        begin
                            L[index] := RightStr(L[index], Length(L[index])-4);
                            while (L[index] = '') do index := index + 1; 
                            z2 := Length(db.Commands);
                            if (LeftStr(L[index], 1) = '(') and (RightStr(L[index], 1) <> ')') then
                            begin
                                db := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                            end else begin
                                db := makeListOfCommands(getScopedCommands(L, index, L[index], 0));
                            end;
                            index := index + 1;
                            while (L[index] = '') do index := index + 1; 
                            z3 := Length(db.Commands);
                            if (LeftStr(L[index], 1) = '{') and (RightStr(L[index], 1) <> '}') then
                            begin
                                db := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                            end else begin
                                db := makeListOfCommands(getScopedCommands(L, index, L[index], 0));
                            end;
                            SetLength(db.Conditionals[z].ElifItems, z1+1);
                            db.Conditionals[z].ElifItems[z1].Condition := z2;
                            db.Conditionals[z].ElifItems[z1].Instruction := z3;
                            z1 := z1 + 1;
                        end else if checkWord(L[index], 'else', 4) then
                        begin
                            L[index] := RightStr(L[index], Length(L[index])-4);
                            while (L[index] = '') do index := index + 1; 
                            z3 := Length(db.Commands);
                            if (LeftStr(L[index], 1) = '{') and (RightStr(L[index], 1) <> '}') then
                            begin
                                db := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                            end else begin
                                db := makeListOfCommands(getScopedCommands(L, index, L[index], 0));
                            end;
                            db.Conditionals[z].ElseItem := z3;
                            ConditionBuilt := True;
                        end else begin
                            Dec(Index);
                            ConditionBuilt := True;
                        end;
                    end;
                    //until ConditionBuilt;
                    db.Commands[x][y] := buildDoIf(z);
                end else if checkWord(L[index], 'function', 8) then begin
                    L[index] := RightStr(L[index], Length(L[index])-8);
                    while (L[index] = '') do index := index + 1; 
                    z := Length(Scripts);
                    SetLength(Scripts, z+1);
                    writeln('attempt new function at ', z, #9, ' coords ', x, ' ', y);
                    if (LeftStr(L[index], 1) = '(') then
                    begin
                        //z1 := Length(db.Commands);
                        if (LeftStr(L[index], 1) = '(') and (RightStr(L[index], 1) <> ')') then
                        begin
                            N := getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1));
                        end else begin
                            //N := getScopedCommand(index, L[index]);
                            //if (LeftStr(L[index], 1) = '(') then RightStr(L[index], Length(L[index])-1);
                            //writeln(L[index]);
                            N := getScopedCommands(L, index, L[index], 0);
                        end;
                        index := index + 1;
                    end else begin
                        SetLength(N, 0);
                    end;
                    writeln(Length(db.commands[x]));
                    SetLength(db.commands[x], Length(db.commands[x])+1);
                    if (LeftStr(L[index], 1) = '{') and (RightStr(L[index], 1) <> '}') then
                    begin
                        Scripts[z] := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)), N);
                    end else begin
                        Scripts[z] := makeListOfCommands(getScopedCommands(L, index, L[index], 0), N);
                    end;
                    writeln('building new function at ', z, #9, ' coords ', x, ' ', y);
                    writeln(Length(Scripts[z].commands));
                    writeln(Length(Scripts[z].commands[0]));
                    writeln(Length(db.commands));
                    writeln(Length(db.commands[x]));
                    writeln();
                    //writeln('lens ', Length(db.Commands), #9, Length(db.Commands[x]));
                    writeln();
                    db.Commands[x][y] := buildCreateFunction(z);
                    writeln('new function at ', #9, z);
                    SetLength(N, 0);
                    while (L[index] = '') do index := index + 1; 
                //end else if checkWord(L[index], 'fun', 3) then begin
                //    L[index] := RightStr(L[index], Length(L[index])-3);
                //    while (L[index] = '') do index := index + 1; 
                //    z := Length(Scripts);
                //    SetLength(Scripts, z+1);
                //    if (LeftStr(L[index], 1) = '(') then
                //    begin
                //        //z1 := Length(db.Commands);
                //        if (LeftStr(L[index], 1) = '(') and (RightStr(L[index], 1) <> ')') then
                //        begin
                //            N := getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1));
                //        end else begin
                //            //N := getScopedCommand(index, L[index]);
                //            //if (LeftStr(L[index], 1) = '(') then RightStr(L[index], Length(L[index])-1);
                //            //writeln(L[index]);
                //            N := getScopedCommands(L, index, L[index], 0);
                //        end;
                //        index := index + 1;
                //    end else begin
                //        SetLength(N, 0);
                //    end;
                //    if (LeftStr(L[index], 1) = '{') and (RightStr(L[index], 1) <> '}') then
                //    begin
                //        makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)), Scripts[z], N);
                //    end else begin
                //        makeListOfCommands(getScopedCommands(L, index, L[index], 0), Scripts[z], N);
                //    end;
                //    db.Commands[x][y] := buildCreateFunction(z);
                //    writeln('new function at ', #9, z);
                //    SetLength(N, 0);
                //    while (L[index] = '') do index := index + 1; 
                //    //
                end else if LeftStr(L[index], 1) = '(' then begin
                    //L[index] := RightStr(L[index], Length(L[index])-1);
                    //while (L[index] = '') do index := index + 1; 
                    z := Length(Scripts);
                    SetLength(Scripts, z+1);
                    Scripts[z] := makeListOfCommands(getScopedCommands(L, index, RightStr(L[index], Length(L[index])-1)));
                    db.Commands[x][y] := buildCreateFunction(z);
                end else begin
                    Val(L[index], Num, Code);
                    if Code <> 0 then
                    begin
                        db.Commands[x][y] := buildCmdEval(L[index]);
                    end else begin
                        db.Commands[x][y] := buildCmdPush(buildNumber(Num));
                    end;
                end;
            end;
        end;
        y := y+1;
        Inc(index);
    end;
    writeln('done');
    Result := db;
end;


function PSEnvironment.buildCommands(input : String) : PSCommandDB;
var
    L : TStringArray;
    i : String;
begin
    L := splitToWords(input);
    writeln('split-bgn');
    for i in L do writeln(i);
    writeln('split-end'); 
    writeln('');
    L := input.Split([' ', #9, #13, #10]);
    Result := makeListOfCommands(L);
end;
